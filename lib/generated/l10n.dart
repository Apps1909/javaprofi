// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class S {
  S();

  static S? _current;

  static S get current {
    assert(_current != null,
        'No instance of S was loaded. Try to initialize the S delegate before accessing S.current.');
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<S> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = S();
      S._current = instance;

      return instance;
    });
  }

  static S of(BuildContext context) {
    final instance = S.maybeOf(context);
    assert(instance != null,
        'No instance of S present in the widget tree. Did you add S.delegate in localizationsDelegates?');
    return instance!;
  }

  static S? maybeOf(BuildContext context) {
    return Localizations.of<S>(context, S);
  }

  /// `What is Java, where is it used and is it promising?`
  String get JavaIntroTitle {
    return Intl.message(
      'What is Java, where is it used and is it promising?',
      name: 'JavaIntroTitle',
      desc: '',
      args: [],
    );
  }

  /// `Java это строго типизированный язык программирования общего назначения. \n\nПочему он строго типизированный мы узнаем позже, а то, что он общего назначения означает, что в принципе на нем можно писать всё что угодно. Но ясное дело всегда есть сферы в которых тот или иной язык показывает себя лучше остальных. На java в основном создаются Android приложения или Java EE приложения. Второе - это грубо говоря сайты. Данный курс сосредоточен на втором.  \n\nЕсли посмотреть на график самых популярных языков программирования в 2023 году, который представлен ниже, то очевидно, что Java является одним из самых популярных языков программирования сегодня (второй по популярности).`
  String get JavaIntro1 {
    return Intl.message(
      'Java это строго типизированный язык программирования общего назначения. \n\nПочему он строго типизированный мы узнаем позже, а то, что он общего назначения означает, что в принципе на нем можно писать всё что угодно. Но ясное дело всегда есть сферы в которых тот или иной язык показывает себя лучше остальных. На java в основном создаются Android приложения или Java EE приложения. Второе - это грубо говоря сайты. Данный курс сосредоточен на втором.  \n\nЕсли посмотреть на график самых популярных языков программирования в 2023 году, который представлен ниже, то очевидно, что Java является одним из самых популярных языков программирования сегодня (второй по популярности).',
      name: 'JavaIntro1',
      desc: '',
      args: [],
    );
  }

  /// `Поэтому на вопрос "Стоит ли изучать Java?" сегодня можно смело отвечать - ДА СТОИТ.`
  String get JavaIntro2 {
    return Intl.message(
      'Поэтому на вопрос "Стоит ли изучать Java?" сегодня можно смело отвечать - ДА СТОИТ.',
      name: 'JavaIntro2',
      desc: '',
      args: [],
    );
  }

  /// `Создадим первую java программу`
  String get JavaFirstProgramTitle {
    return Intl.message(
      'Создадим первую java программу',
      name: 'JavaFirstProgramTitle',
      desc: '',
      args: [],
    );
  }

  /// `Создадим и запустим первую Java программу.\n\nВ результате выполнения действий приведенных в прошлом уроке все библиотеки Java доступны на нашем компьютере и мы можем использовать их чтобы писать Java код и компилировать его.\nПишется Java код в фале с расширением .java. То есть, например, создадим: HelloWorld.java`
  String get JavaFirstProgram {
    return Intl.message(
      'Создадим и запустим первую Java программу.\n\nВ результате выполнения действий приведенных в прошлом уроке все библиотеки Java доступны на нашем компьютере и мы можем использовать их чтобы писать Java код и компилировать его.\nПишется Java код в фале с расширением .java. То есть, например, создадим: HelloWorld.java',
      name: 'JavaFirstProgram',
      desc: '',
      args: [],
    );
  }

  /// `Зайдем в этот файл и добавим в него нашу первую программу, которая будет выводить 'Hello World!!!' в консоль.`
  String get JavaFirstProgram2 {
    return Intl.message(
      'Зайдем в этот файл и добавим в него нашу первую программу, которая будет выводить \'Hello World!!!\' в консоль.',
      name: 'JavaFirstProgram2',
      desc: '',
      args: [],
    );
  }

  /// `Здесь можно увидеть функцию main, класс с именем HelloWorld и вызов функции println.\nПока всё, что нужно знать об этой программе это что весь код в любом Java приложении запускается из функции main и функция main может быть только одна на всё приложение. Класс в котором находиться функция main должен иметь имя идентичное имени файла. \n\nФункция System.out.prontln() используется для вывода данных в консоль. То что будет выводиться помещаем в скобочки.\n\nЧто такое функции, классы и прочее будет разобрано потом.`
  String get JavaFirstProgram3 {
    return Intl.message(
      'Здесь можно увидеть функцию main, класс с именем HelloWorld и вызов функции println.\nПока всё, что нужно знать об этой программе это что весь код в любом Java приложении запускается из функции main и функция main может быть только одна на всё приложение. Класс в котором находиться функция main должен иметь имя идентичное имени файла. \n\nФункция System.out.prontln() используется для вывода данных в консоль. То что будет выводиться помещаем в скобочки.\n\nЧто такое функции, классы и прочее будет разобрано потом.',
      name: 'JavaFirstProgram3',
      desc: '',
      args: [],
    );
  }

  /// `Компиляция первой программы`
  String get JavaFirstProgramTitle1 {
    return Intl.message(
      'Компиляция первой программы',
      name: 'JavaFirstProgramTitle1',
      desc: '',
      args: [],
    );
  }

  /// `Итак в консоли с помощью команды cd переходим в нашу папку с нашей программой. \n\nДля этого сначала выделяем путь папки с программой:`
  String get JavaFirstProgram4 {
    return Intl.message(
      'Итак в консоли с помощью команды cd переходим в нашу папку с нашей программой. \n\nДля этого сначала выделяем путь папки с программой:',
      name: 'JavaFirstProgram4',
      desc: '',
      args: [],
    );
  }

  /// `и вставляем его после cd в консоли чтобы перейти в эту папку.:`
  String get JavaFirstProgram5 {
    return Intl.message(
      'и вставляем его после cd в консоли чтобы перейти в эту папку.:',
      name: 'JavaFirstProgram5',
      desc: '',
      args: [],
    );
  }

  /// `Теперь в консоли мы в папке Programs.                                                                 `
  String get JavaFirstProgram6 {
    return Intl.message(
      'Теперь в консоли мы в папке Programs.                                                                 ',
      name: 'JavaFirstProgram6',
      desc: '',
      args: [],
    );
  }

  /// `Теперь через консоль мы можем напрямую работать с файлами в ней, так как мы в нее перешли.\n\nКомпилируем файл HelloWorld.java с помощью javac.`
  String get JavaFirstProgram7 {
    return Intl.message(
      'Теперь через консоль мы можем напрямую работать с файлами в ней, так как мы в нее перешли.\n\nКомпилируем файл HelloWorld.java с помощью javac.',
      name: 'JavaFirstProgram7',
      desc: '',
      args: [],
    );
  }

  /// `Как можно увидеть, в папке появился файлик с байт кодом, который можно запустить на нашем компьютере через java машину командой java.`
  String get JavaFirstProgram8 {
    return Intl.message(
      'Как можно увидеть, в папке появился файлик с байт кодом, который можно запустить на нашем компьютере через java машину командой java.',
      name: 'JavaFirstProgram8',
      desc: '',
      args: [],
    );
  }

  /// `Запустим первую java программу`
  String get JavaFirstProgramTitle3 {
    return Intl.message(
      'Запустим первую java программу',
      name: 'JavaFirstProgramTitle3',
      desc: '',
      args: [],
    );
  }

  /// `Запускаем программу и видим Hello World!!! в консоли. Все работает.`
  String get JavaFirstProgram9 {
    return Intl.message(
      'Запускаем программу и видим Hello World!!! в консоли. Все работает.',
      name: 'JavaFirstProgram9',
      desc: '',
      args: [],
    );
  }

  /// `Абстрактные классы`
  String get JavaAbstractTitle {
    return Intl.message(
      'Абстрактные классы',
      name: 'JavaAbstractTitle',
      desc: '',
      args: [],
    );
  }

  /// `Абстрактный класс - общий концепт чего-либо. \n\nЭто класс, который содержит в себе нереализованные методы (называются абстрактными методами), которые наследники должны реализовать. \n\nПод 'нереализованные' имеется ввиду, что такие методы только объявляются в абстрактном классе, то есть у них нет тела, то есть кода внутри {}.\n\nАбстрактные методы помечаются ключевым словом abstract.\n\nПриведем пример абстрактного класса. Например птица. Птица это общий концепт для любой птицы, будь-то воробей или попугай.\n\nАбстрактный класс птицы может иметь не только абстрактные методы, а и методы с реализацией.\nНапример. Любая птица имеет крылья. Махание крыльями примерно ОДИНАКОВОЕ у всех птиц (ну по крайней мере представим так). Соответственно можно создать в абстрактном классе не абстрактный, а обычный метод с реализацией для махания крыльями и все классы птиц, которые наследуют от абстрактного класса Птица будут по умолчанию пользоваться методом для махания крыльями из абстрактного класса.\n\nАбстрактный же метод в абстрактном классе Птица будет иметь смысл определить в таком случае:\nЛюбая птица издает какие-то звуки. Но в этом уже случае почти все птицы издают РАЗНЫЕ звуки. Значит в абстрактном классе Птица должен быть абстрактный метод для издавания звуков, который наследующие от этого абстрактного класса птицы обязаны переопределить.\n\nТо есть суть в том, что если мы знаем, что у класса, который мы создаем будут наследники и у всех них будет метод, который будет выполнять одно и то же действие (например, издавание звуков у птиц), но результат этого метода у всех наследников будет разным (разные звуки), то есть смысл объявить создаваемый нами класс абстрактным и объявить этот метод абстрактным.\n\nИз примеров абстрактных классов можно еще привести, например, Форма (форму реализует например куб и треугольник), средство передвижения (реализует машина или велосипед)\n\nВоспринимайте абстрактный класс как недопиленный класс, который наследники должны допилить по своему посредством реализации абстрактных методов этого абстрактного класса. Недопиленный он потому что в нем всё же присутствуют реализации (пример метода махания крыльями), но в нем и хватает абстрактных методов, которые должны допилить наследники.                             `
  String get JavaAbstract1 {
    return Intl.message(
      'Абстрактный класс - общий концепт чего-либо. \n\nЭто класс, который содержит в себе нереализованные методы (называются абстрактными методами), которые наследники должны реализовать. \n\nПод \'нереализованные\' имеется ввиду, что такие методы только объявляются в абстрактном классе, то есть у них нет тела, то есть кода внутри {}.\n\nАбстрактные методы помечаются ключевым словом abstract.\n\nПриведем пример абстрактного класса. Например птица. Птица это общий концепт для любой птицы, будь-то воробей или попугай.\n\nАбстрактный класс птицы может иметь не только абстрактные методы, а и методы с реализацией.\nНапример. Любая птица имеет крылья. Махание крыльями примерно ОДИНАКОВОЕ у всех птиц (ну по крайней мере представим так). Соответственно можно создать в абстрактном классе не абстрактный, а обычный метод с реализацией для махания крыльями и все классы птиц, которые наследуют от абстрактного класса Птица будут по умолчанию пользоваться методом для махания крыльями из абстрактного класса.\n\nАбстрактный же метод в абстрактном классе Птица будет иметь смысл определить в таком случае:\nЛюбая птица издает какие-то звуки. Но в этом уже случае почти все птицы издают РАЗНЫЕ звуки. Значит в абстрактном классе Птица должен быть абстрактный метод для издавания звуков, который наследующие от этого абстрактного класса птицы обязаны переопределить.\n\nТо есть суть в том, что если мы знаем, что у класса, который мы создаем будут наследники и у всех них будет метод, который будет выполнять одно и то же действие (например, издавание звуков у птиц), но результат этого метода у всех наследников будет разным (разные звуки), то есть смысл объявить создаваемый нами класс абстрактным и объявить этот метод абстрактным.\n\nИз примеров абстрактных классов можно еще привести, например, Форма (форму реализует например куб и треугольник), средство передвижения (реализует машина или велосипед)\n\nВоспринимайте абстрактный класс как недопиленный класс, который наследники должны допилить по своему посредством реализации абстрактных методов этого абстрактного класса. Недопиленный он потому что в нем всё же присутствуют реализации (пример метода махания крыльями), но в нем и хватает абстрактных методов, которые должны допилить наследники.                             ',
      name: 'JavaAbstract1',
      desc: '',
      args: [],
    );
  }

  /// `Абстрактный класс`
  String get JavaAbstractTitle1 {
    return Intl.message(
      'Абстрактный класс',
      name: 'JavaAbstractTitle1',
      desc: '',
      args: [],
    );
  }

  /// `Поясним на примере:                                                                                     `
  String get JavaAbstract2 {
    return Intl.message(
      'Поясним на примере:                                                                                     ',
      name: 'JavaAbstract2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAbstract3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAbstract3',
      desc: '',
      args: [],
    );
  }

  /// `Аннотации`
  String get JavaAnnotTitle {
    return Intl.message(
      'Аннотации',
      name: 'JavaAnnotTitle',
      desc: '',
      args: [],
    );
  }

  /// `Что такое аннотация в Java? \n\nПредставьте себе склад с коробками. На каждой из коробок есть надпись, которая говорит тому кто будет отгружать эти коробки из склада куда эту коробку отгружать. \n\nТак вот, по этой аналогии коробка это класс или переменная или метод, а аннотация это эта надпись, а тот кто отгружает коробку и смотрит на надпись это компилятор Java, который смотрит на аннотацию и делает что-либо с классом или методом или переменной.\n\nНапример с помощью аннотации SafeVarargs над классом можно подавить некоторые предупреждения, которые компилятор бы выдал если бы над этим классом не было этой аннотации. То есть компилятор увидел над классом аннотацию SafeVarargs, которая говорит компилятору не выдавай предупреждения о классе и он этого делать не будет. \nИли аннотация Documented скажет компилятору задокументировать класс над которым она стоит.\n\nДалее на примерах разберем некоторые важные аннотации.`
  String get JavaAnnot1 {
    return Intl.message(
      'Что такое аннотация в Java? \n\nПредставьте себе склад с коробками. На каждой из коробок есть надпись, которая говорит тому кто будет отгружать эти коробки из склада куда эту коробку отгружать. \n\nТак вот, по этой аналогии коробка это класс или переменная или метод, а аннотация это эта надпись, а тот кто отгружает коробку и смотрит на надпись это компилятор Java, который смотрит на аннотацию и делает что-либо с классом или методом или переменной.\n\nНапример с помощью аннотации SafeVarargs над классом можно подавить некоторые предупреждения, которые компилятор бы выдал если бы над этим классом не было этой аннотации. То есть компилятор увидел над классом аннотацию SafeVarargs, которая говорит компилятору не выдавай предупреждения о классе и он этого делать не будет. \nИли аннотация Documented скажет компилятору задокументировать класс над которым она стоит.\n\nДалее на примерах разберем некоторые важные аннотации.',
      name: 'JavaAnnot1',
      desc: '',
      args: [],
    );
  }

  /// `Аннотация Override`
  String get JavaAnnotTitle1 {
    return Intl.message(
      'Аннотация Override',
      name: 'JavaAnnotTitle1',
      desc: '',
      args: [],
    );
  }

  /// `Override (должно быть самая часто встречающаяся аннотация). Этой аннотацией помечается метод для того чтобы всем программистам смотрящим на него было видно, что метод переопределяется (то есть в родительском классе класса в котором находиться этот метод помеченный аннотацией Override есть метод с таким же именем). \n\nПоясним на примере:                                                       `
  String get JavaAnnot2 {
    return Intl.message(
      'Override (должно быть самая часто встречающаяся аннотация). Этой аннотацией помечается метод для того чтобы всем программистам смотрящим на него было видно, что метод переопределяется (то есть в родительском классе класса в котором находиться этот метод помеченный аннотацией Override есть метод с таким же именем). \n\nПоясним на примере:                                                       ',
      name: 'JavaAnnot2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAnnot3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAnnot3',
      desc: '',
      args: [],
    );
  }

  /// `Также еще служит как страховка. То есть представим, что мы например случайно удалили или закомментировали метод в родительском классе, который переопределялся наследником. Если этот переопределяемый в наследнике метод был помечен аннотацией Override, то при запуске компилятор выдаст соответствующую ошибку сообщающую о том, что аннотация Override здесь ни к чему, поскольку в родительском методе нет метода с таким названием. В примере ниже в ParentClass мы не определили метода с именем someMethod (точнее метод закомментирован, как видим), поэтому программа выдаст ошибку. `
  String get JavaAnnot4 {
    return Intl.message(
      'Также еще служит как страховка. То есть представим, что мы например случайно удалили или закомментировали метод в родительском классе, который переопределялся наследником. Если этот переопределяемый в наследнике метод был помечен аннотацией Override, то при запуске компилятор выдаст соответствующую ошибку сообщающую о том, что аннотация Override здесь ни к чему, поскольку в родительском методе нет метода с таким названием. В примере ниже в ParentClass мы не определили метода с именем someMethod (точнее метод закомментирован, как видим), поэтому программа выдаст ошибку. ',
      name: 'JavaAnnot4',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAnnot5 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAnnot5',
      desc: '',
      args: [],
    );
  }

  /// `Аннотация @FunctionslInterface`
  String get JavaAnnotTitle3 {
    return Intl.message(
      'Аннотация @FunctionslInterface',
      name: 'JavaAnnotTitle3',
      desc: '',
      args: [],
    );
  }

  /// `FunctionalInterface - если над интерфейсом написать аннотацию @FunctionalInterface, то в такой интерфейс нельзя будет добавить более одного абстрактного метода (интерфейс с одним единственным абстрактным методом называется функциональным интерфейсом). \n\nТо есть если код содержит в себе интерфейс, который помечен аннотацией FunctionalInterface и который при этом содержит несколько абстрактных методов, то такой код не скомпилируется.\n\nЧто такое функциональный интерфейс, зачем он нужен и как им пользоваться разберем немного позже.\n\nПоясним на примере:                                                       `
  String get JavaAnnot6 {
    return Intl.message(
      'FunctionalInterface - если над интерфейсом написать аннотацию @FunctionalInterface, то в такой интерфейс нельзя будет добавить более одного абстрактного метода (интерфейс с одним единственным абстрактным методом называется функциональным интерфейсом). \n\nТо есть если код содержит в себе интерфейс, который помечен аннотацией FunctionalInterface и который при этом содержит несколько абстрактных методов, то такой код не скомпилируется.\n\nЧто такое функциональный интерфейс, зачем он нужен и как им пользоваться разберем немного позже.\n\nПоясним на примере:                                                       ',
      name: 'JavaAnnot6',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAnnot7 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAnnot7',
      desc: '',
      args: [],
    );
  }

  /// `Как видим код не скомпилировался.                                                 `
  String get JavaAnnot8 {
    return Intl.message(
      'Как видим код не скомпилировался.                                                 ',
      name: 'JavaAnnot8',
      desc: '',
      args: [],
    );
  }

  /// `Аннотация @Deprecated`
  String get JavaAnnotTitle4 {
    return Intl.message(
      'Аннотация @Deprecated',
      name: 'JavaAnnotTitle4',
      desc: '',
      args: [],
    );
  }

  /// `Deprecated - для пометки устаревших методов или классов. \n\nПри вызове метода вызовется предупреждение, что метод устарел и что его лучше не использовать.\n\nПоясним на примере:                                                       `
  String get JavaAnnot9 {
    return Intl.message(
      'Deprecated - для пометки устаревших методов или классов. \n\nПри вызове метода вызовется предупреждение, что метод устарел и что его лучше не использовать.\n\nПоясним на примере:                                                       ',
      name: 'JavaAnnot9',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAnnot10 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAnnot10',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, код скомпилировался, но при компиляции было вызвано предупреждение.                                                 `
  String get JavaAnnot11 {
    return Intl.message(
      'Как видим, код скомпилировался, но при компиляции было вызвано предупреждение.                                                 ',
      name: 'JavaAnnot11',
      desc: '',
      args: [],
    );
  }

  /// `Создание собственных (кастомных) аннотаций.`
  String get JavaAnnoTitlet5 {
    return Intl.message(
      'Создание собственных (кастомных) аннотаций.',
      name: 'JavaAnnoTitlet5',
      desc: '',
      args: [],
    );
  }

  /// `Можно создавать свои аннотации с помощью аннотации @interface. \n\nПри создании аннотации используются вспомогательные аннотации. Они пишутся над аннотацией @interface.\n\n@Target - этой аннотацией указываем к чему будет применяться создаваемая аннотация - если укажем TYPE, то только к классу, если METHOD, то только к методу, если FIELD, то только к полю, есть и другие значения, но это основные\n\n@Retention - этой аннотацией указываем где будет жить создаваемая аннотация - если укажем RUNTIME, то создаваемая аннотация должна быть доступна джава машине во время выполнения, если CLASS, то аннотация не будет доступна во время выполнения, но будет в скомпилированном джава class файле, если SOURCE, то создаваемая аннотация будет содержаться только в исходном коде. \n\n@Repeatable(...) - создаваемая аннотация может использоваться несколько раз на методе, классе или поле. В скобочках указывается другая кастомная аннотация. Эта другая кастомная аннотация будет хранить в виде массива ВСЕ повторения применения над конкретным методом или классом, или полем той кастомной аннотации над которой мы писали Repeatable.\n\n@Inherited - создаваемая аннотация наследуется классами, которые наследуют класс к которому применена аннотация.\n\n@Documented - информация о создаваемой аннотации появиться в JavaDoc-документации                                                 `
  String get JavaAnnot13 {
    return Intl.message(
      'Можно создавать свои аннотации с помощью аннотации @interface. \n\nПри создании аннотации используются вспомогательные аннотации. Они пишутся над аннотацией @interface.\n\n@Target - этой аннотацией указываем к чему будет применяться создаваемая аннотация - если укажем TYPE, то только к классу, если METHOD, то только к методу, если FIELD, то только к полю, есть и другие значения, но это основные\n\n@Retention - этой аннотацией указываем где будет жить создаваемая аннотация - если укажем RUNTIME, то создаваемая аннотация должна быть доступна джава машине во время выполнения, если CLASS, то аннотация не будет доступна во время выполнения, но будет в скомпилированном джава class файле, если SOURCE, то создаваемая аннотация будет содержаться только в исходном коде. \n\n@Repeatable(...) - создаваемая аннотация может использоваться несколько раз на методе, классе или поле. В скобочках указывается другая кастомная аннотация. Эта другая кастомная аннотация будет хранить в виде массива ВСЕ повторения применения над конкретным методом или классом, или полем той кастомной аннотации над которой мы писали Repeatable.\n\n@Inherited - создаваемая аннотация наследуется классами, которые наследуют класс к которому применена аннотация.\n\n@Documented - информация о создаваемой аннотации появиться в JavaDoc-документации                                                 ',
      name: 'JavaAnnot13',
      desc: '',
      args: [],
    );
  }

  /// `Создание собственных (кастомных) аннотаций.`
  String get JavaAnnotTitle6 {
    return Intl.message(
      'Создание собственных (кастомных) аннотаций.',
      name: 'JavaAnnotTitle6',
      desc: '',
      args: [],
    );
  }

  /// `Поясним на примере:                                                       `
  String get JavaAnnot15 {
    return Intl.message(
      'Поясним на примере:                                                       ',
      name: 'JavaAnnot15',
      desc: '',
      args: [],
    );
  }

  /// `Анонимный класс`
  String get JavaAnonClass1 {
    return Intl.message(
      'Анонимный класс',
      name: 'JavaAnonClass1',
      desc: '',
      args: [],
    );
  }

  /// `Анонимный класс - одноразовая реализация интерфейса без создания полноценного класса.\n\nТо есть нам не нужно создавать много объектов, будет только один с данной реализацией.\n\nПример программы:                                                `
  String get JavaAnonClass2 {
    return Intl.message(
      'Анонимный класс - одноразовая реализация интерфейса без создания полноценного класса.\n\nТо есть нам не нужно создавать много объектов, будет только один с данной реализацией.\n\nПример программы:                                                ',
      name: 'JavaAnonClass2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAnonClass3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAnonClass3',
      desc: '',
      args: [],
    );
  }

  /// `Одноразовый он очевидно почему. \nПотому что мы не создавали полноценный отдельный класс реализующий интерфейс, как мы делали это раньше. И мы даже не создавали ссылку для работы с созданным объектом, мы сразу вызвали у него .pow(3,6).\n\nТо есть вся эта реализация существовала для одной цели - вызова метода .pow(3,6) в методе println и всё. И больше нигде мы ее использовать не можем да и не должно быть нужно она одноразовая.                                `
  String get JavaAnonClass4 {
    return Intl.message(
      'Одноразовый он очевидно почему. \nПотому что мы не создавали полноценный отдельный класс реализующий интерфейс, как мы делали это раньше. И мы даже не создавали ссылку для работы с созданным объектом, мы сразу вызвали у него .pow(3,6).\n\nТо есть вся эта реализация существовала для одной цели - вызова метода .pow(3,6) в методе println и всё. И больше нигде мы ее использовать не можем да и не должно быть нужно она одноразовая.                                ',
      name: 'JavaAnonClass4',
      desc: '',
      args: [],
    );
  }

  /// `Методы сервлета`
  String get JavaServlMethods1 {
    return Intl.message(
      'Методы сервлета',
      name: 'JavaServlMethods1',
      desc: '',
      args: [],
    );
  }

  /// `Помимо doGet у сервлета есть и другие методы.\n\nРассмотрим вкратце зачем нужны методы init, doPost, service и destroy.                                         `
  String get JavaServlMethods2 {
    return Intl.message(
      'Помимо doGet у сервлета есть и другие методы.\n\nРассмотрим вкратце зачем нужны методы init, doPost, service и destroy.                                         ',
      name: 'JavaServlMethods2',
      desc: '',
      args: [],
    );
  }

  /// `Массивы в java`
  String get JavaArrays1 {
    return Intl.message(
      'Массивы в java',
      name: 'JavaArrays1',
      desc: '',
      args: [],
    );
  }

  /// `Рассмотрим массивы. \n\nВ прошлых у нас была переменная int a=31; хранящая одно число 31.\n\nА что если мы хотим иметь переменную в которой будет храниться 100 разных числовых значений.\nТакая переменная называется массивом.  \n\nОбъявляется массив так:\nint[] a;\n\n[] значат, что это массив и в нем будет храниться много значений (типа int в данном случае).\n\nПока массив а был просто объявлен. Чтобы в него поместить значения нужно выделить место в памяти где будут храниться значения массива и указать конкретное количество значений, которое может храниться в массиве.\n\nКлючевым словом new мы выделяем память под массив, который может вмещать максимум 5 элементов. \na = new int[5];\nПосле этого можно записывать в эту память числа.\n\nОбъявление и выделение памяти можно записать в одну строку как:\nint[] a = new int[5];\n\t\t\nТакже можно при создании массива сразу записать в них значения.\nint[] b = {56, 3, 7, 63, 13};\n\nЗаранее с помощью new память под эти значения выделять не нужно, так как мы сразу записываем в память значения.`
  String get JavaArrays2 {
    return Intl.message(
      'Рассмотрим массивы. \n\nВ прошлых у нас была переменная int a=31; хранящая одно число 31.\n\nА что если мы хотим иметь переменную в которой будет храниться 100 разных числовых значений.\nТакая переменная называется массивом.  \n\nОбъявляется массив так:\nint[] a;\n\n[] значат, что это массив и в нем будет храниться много значений (типа int в данном случае).\n\nПока массив а был просто объявлен. Чтобы в него поместить значения нужно выделить место в памяти где будут храниться значения массива и указать конкретное количество значений, которое может храниться в массиве.\n\nКлючевым словом new мы выделяем память под массив, который может вмещать максимум 5 элементов. \na = new int[5];\nПосле этого можно записывать в эту память числа.\n\nОбъявление и выделение памяти можно записать в одну строку как:\nint[] a = new int[5];\n\t\t\nТакже можно при создании массива сразу записать в них значения.\nint[] b = {56, 3, 7, 63, 13};\n\nЗаранее с помощью new память под эти значения выделять не нужно, так как мы сразу записываем в память значения.',
      name: 'JavaArrays2',
      desc: '',
      args: [],
    );
  }

  /// `Взаимодействие с массивом`
  String get JavaArrays3 {
    return Intl.message(
      'Взаимодействие с массивом',
      name: 'JavaArrays3',
      desc: '',
      args: [],
    );
  }

  /// `Итак рассмотрим как мы можем взаимодействовать с массивом.\n\nНиже в примере программы создается массив b, который содержит 5 числовых значений.\n\nКаждое из пяти значений имеет свой порядковый номер в массиве: \n56 - имеет номер 0, 3 -  имеет номер 1, 7 -  имеет номер 2, 63 - имеет номер 3, 13 - имеет номер 4. Очевидно, что номера элементам массива выдаются по порядку, то есть первому элементу в массиве номер ноль, второму номер 1, третьему элементу номер 2 и т.д.\n\nТакже как видим порядковый номер в массивах начинается с нуля, а не единицы.\n\nПравильно этот порядковый номер в массиве называть индексом.\n\nПоясним на примере.`
  String get JavaArrays4 {
    return Intl.message(
      'Итак рассмотрим как мы можем взаимодействовать с массивом.\n\nНиже в примере программы создается массив b, который содержит 5 числовых значений.\n\nКаждое из пяти значений имеет свой порядковый номер в массиве: \n56 - имеет номер 0, 3 -  имеет номер 1, 7 -  имеет номер 2, 63 - имеет номер 3, 13 - имеет номер 4. Очевидно, что номера элементам массива выдаются по порядку, то есть первому элементу в массиве номер ноль, второму номер 1, третьему элементу номер 2 и т.д.\n\nТакже как видим порядковый номер в массивах начинается с нуля, а не единицы.\n\nПравильно этот порядковый номер в массиве называть индексом.\n\nПоясним на примере.',
      name: 'JavaArrays4',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaArrays5 {
    return Intl.message(
      'Вывод:',
      name: 'JavaArrays5',
      desc: '',
      args: [],
    );
  }

  /// `Обход массива циклом`
  String get JavaArrays6 {
    return Intl.message(
      'Обход массива циклом',
      name: 'JavaArrays6',
      desc: '',
      args: [],
    );
  }

  /// `Выведем все элементы массива b по порядку с помощью for. \n\nЛюбой массив имеет внутри себя переменную length в которой храниться количество элементов массива. Это можно использовать для обхода элементов циклом.\n\nПоясним на примере.`
  String get JavaArrays7 {
    return Intl.message(
      'Выведем все элементы массива b по порядку с помощью for. \n\nЛюбой массив имеет внутри себя переменную length в которой храниться количество элементов массива. Это можно использовать для обхода элементов циклом.\n\nПоясним на примере.',
      name: 'JavaArrays7',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaArrays8 {
    return Intl.message(
      'Вывод:',
      name: 'JavaArrays8',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, можно легко пройтись по элементам массива и совершать с каждым какие-то действия на каждой итерации. Например, выводить на консоль каждый элемент, как в приведенном примере.`
  String get JavaArrays9 {
    return Intl.message(
      'Как видим, можно легко пройтись по элементам массива и совершать с каждым какие-то действия на каждой итерации. Например, выводить на консоль каждый элемент, как в приведенном примере.',
      name: 'JavaArrays9',
      desc: '',
      args: [],
    );
  }

  /// `Обход массива циклом for-each`
  String get JavaArrays10 {
    return Intl.message(
      'Обход массива циклом for-each',
      name: 'JavaArrays10',
      desc: '',
      args: [],
    );
  }

  /// `Для обхода элементов массива можно использовать особенный вид for цикла. \n\nНазывается он for-each\n\nИспользуя цикл foreach нам не нужно знать размер массива.\n\nВ примере ниже цикл foreach начиная с первого элемента массива b поочереди берет элементы и помещает их в singleArrayElement\n\nПоясним на примере.`
  String get JavaArrays11 {
    return Intl.message(
      'Для обхода элементов массива можно использовать особенный вид for цикла. \n\nНазывается он for-each\n\nИспользуя цикл foreach нам не нужно знать размер массива.\n\nВ примере ниже цикл foreach начиная с первого элемента массива b поочереди берет элементы и помещает их в singleArrayElement\n\nПоясним на примере.',
      name: 'JavaArrays11',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaArrays12 {
    return Intl.message(
      'Вывод:',
      name: 'JavaArrays12',
      desc: '',
      args: [],
    );
  }

  /// `То есть на первой итерации этого цикла берется первый элемент массива b и помещается в переменную singleArrayElement, которая того же типа, что и массив b и в теле цикла можно работать с первым элементом массива через эту переменную, на второй итерации цикла второй элемент помещается в singleArrayElement вместо первого и происходит работа уже со вторым элементом массива, на третьей помещается третий и т.д. до конца массива.\n\nВажно знать, что singleArrayElement это не копия элемента массива, это именно элемент массива, то есть изменяя singleArrayElement мы изменяем элемент массива`
  String get JavaArrays13 {
    return Intl.message(
      'То есть на первой итерации этого цикла берется первый элемент массива b и помещается в переменную singleArrayElement, которая того же типа, что и массив b и в теле цикла можно работать с первым элементом массива через эту переменную, на второй итерации цикла второй элемент помещается в singleArrayElement вместо первого и происходит работа уже со вторым элементом массива, на третьей помещается третий и т.д. до конца массива.\n\nВажно знать, что singleArrayElement это не копия элемента массива, это именно элемент массива, то есть изменяя singleArrayElement мы изменяем элемент массива',
      name: 'JavaArrays13',
      desc: '',
      args: [],
    );
  }

  /// `Двумерные массивы`
  String get JavaArrays14 {
    return Intl.message(
      'Двумерные массивы',
      name: 'JavaArrays14',
      desc: '',
      args: [],
    );
  }

  /// `Также массивы бывают многомерными. \n\nТо есть представьте массив в котором каждый элемент это массив чисел. \nТакой массив чисел, который мы разбирали только что. \n\nТо есть это массив массивов чисел. Массив массивов называется двухмерным массивом.\n\nНиже пример двухмерного массива. Объявляется он с помощью [][]. Как видим, через запятую перечислены массивы чисел\n\t\tint[][] b = {\n\t\t\t{56, 3, 63, 13},\n\t\t\t{3,67,2},\n\t\t\t{5,5,3,7,9}\n\t\t};\n\t\t\nКак же получить доступ к числам подмассивов. Очень просто. \n\nВ первой скобочке мы пишем индекс нужного нам подмассива.\n\nВо второй скобочке пишем индекс нужного нам числа этого подмассива.\n\nСтрокой кода ниже мы достаем число 2. Мы обращаемся ко второму подмасиву, к третьему элементу этого подмассива.\nSystem.out.println(b[1][2]);\n\nПомним что элементы в массивах нумеруются начиная с нуля. Поэтому 1 и 2, а не 2 и 3.\n\nПоясним на примере.`
  String get JavaArrays15 {
    return Intl.message(
      'Также массивы бывают многомерными. \n\nТо есть представьте массив в котором каждый элемент это массив чисел. \nТакой массив чисел, который мы разбирали только что. \n\nТо есть это массив массивов чисел. Массив массивов называется двухмерным массивом.\n\nНиже пример двухмерного массива. Объявляется он с помощью [][]. Как видим, через запятую перечислены массивы чисел\n\t\tint[][] b = {\n\t\t\t{56, 3, 63, 13},\n\t\t\t{3,67,2},\n\t\t\t{5,5,3,7,9}\n\t\t};\n\t\t\nКак же получить доступ к числам подмассивов. Очень просто. \n\nВ первой скобочке мы пишем индекс нужного нам подмассива.\n\nВо второй скобочке пишем индекс нужного нам числа этого подмассива.\n\nСтрокой кода ниже мы достаем число 2. Мы обращаемся ко второму подмасиву, к третьему элементу этого подмассива.\nSystem.out.println(b[1][2]);\n\nПомним что элементы в массивах нумеруются начиная с нуля. Поэтому 1 и 2, а не 2 и 3.\n\nПоясним на примере.',
      name: 'JavaArrays15',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaArrays16 {
    return Intl.message(
      'Вывод:',
      name: 'JavaArrays16',
      desc: '',
      args: [],
    );
  }

  /// `Обход двумерного массива циклом for-each`
  String get JavaArrays17 {
    return Intl.message(
      'Обход двумерного массива циклом for-each',
      name: 'JavaArrays17',
      desc: '',
      args: [],
    );
  }

  /// `Ниже циклами проходимся по числам которые хранит в себе двухмерный массив и выводим их на консоль.\n\nПоясним на примере.`
  String get JavaArrays18 {
    return Intl.message(
      'Ниже циклами проходимся по числам которые хранит в себе двухмерный массив и выводим их на консоль.\n\nПоясним на примере.',
      name: 'JavaArrays18',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaArrays19 {
    return Intl.message(
      'Вывод:',
      name: 'JavaArrays19',
      desc: '',
      args: [],
    );
  }

  /// `Ключевое слово Assert`
  String get JavaAssert1 {
    return Intl.message(
      'Ключевое слово Assert',
      name: 'JavaAssert1',
      desc: '',
      args: [],
    );
  }

  /// `Ключевое слово assert для проверки какого-либо условия в ходе разработки.\n\nПрограмма выдает исключение, то есть происходит ошибка если выражение в условии после ключевого слова assert возвращает false.\n\nВ итоговом коде не присутствует, так как используется для простого тестирования условий. \n\nЗапускается с ключом -ea.\n\nПоясним на примере:                                                       `
  String get JavaAssert2 {
    return Intl.message(
      'Ключевое слово assert для проверки какого-либо условия в ходе разработки.\n\nПрограмма выдает исключение, то есть происходит ошибка если выражение в условии после ключевого слова assert возвращает false.\n\nВ итоговом коде не присутствует, так как используется для простого тестирования условий. \n\nЗапускается с ключом -ea.\n\nПоясним на примере:                                                       ',
      name: 'JavaAssert2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaAssert3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaAssert3',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, когда выполнение программы доходит до того, что n становиться равным 0 происходит ошибка.                                         `
  String get JavaAssert4 {
    return Intl.message(
      'Как видим, когда выполнение программы доходит до того, что n становиться равным 0 происходит ошибка.                                         ',
      name: 'JavaAssert4',
      desc: '',
      args: [],
    );
  }

  /// `Ключевое слово break`
  String get JavaBreakContinue1 {
    return Intl.message(
      'Ключевое слово break',
      name: 'JavaBreakContinue1',
      desc: '',
      args: [],
    );
  }

  /// `Далее рассмотрим ключевые слова break и continue.\n\nЕсли нужно раньше времени остановить цикл по какому-то условию, то используется ключевое слово break.\n\nПоясним на примере.`
  String get JavaBreakContinue2 {
    return Intl.message(
      'Далее рассмотрим ключевые слова break и continue.\n\nЕсли нужно раньше времени остановить цикл по какому-то условию, то используется ключевое слово break.\n\nПоясним на примере.',
      name: 'JavaBreakContinue2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaBreakContinue3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaBreakContinue3',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, цикл for остановился досрочно, то есть і не дошло до 10, цикл остановился когда переменная а стала равна 25.`
  String get JavaBreakContinue4 {
    return Intl.message(
      'Как видим, цикл for остановился досрочно, то есть і не дошло до 10, цикл остановился когда переменная а стала равна 25.',
      name: 'JavaBreakContinue4',
      desc: '',
      args: [],
    );
  }

  /// `Ключевое слово continue`
  String get JavaBreakContinue5 {
    return Intl.message(
      'Ключевое слово continue',
      name: 'JavaBreakContinue5',
      desc: '',
      args: [],
    );
  }

  /// `Также есть ключевое слово continue.`
  String get JavaBreakContinue6 {
    return Intl.message(
      'Также есть ключевое слово continue.',
      name: 'JavaBreakContinue6',
      desc: '',
      args: [],
    );
  }

  /// `Оно завершает одну текущую итерацию цикла досрочно.      `
  String get JavaBreakContinue7 {
    return Intl.message(
      'Оно завершает одну текущую итерацию цикла досрочно.      ',
      name: 'JavaBreakContinue7',
      desc: '',
      args: [],
    );
  }

  /// `Пример программы:`
  String get JavaBreakContinue8 {
    return Intl.message(
      'Пример программы:',
      name: 'JavaBreakContinue8',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaBreakContinue9 {
    return Intl.message(
      'Вывод:',
      name: 'JavaBreakContinue9',
      desc: '',
      args: [],
    );
  }

  /// `Как можно увидеть в выводе, на седьмой итерации переменная а уже равна 25, а это значит, что на всех оставшихся итерациях (то есть пока і не станет равна 10) будет срабатывать continue, так как на всех этих оставшихся итерациях переменная a равна 25, что также видно в выводе.`
  String get JavaBreakContinue10 {
    return Intl.message(
      'Как можно увидеть в выводе, на седьмой итерации переменная а уже равна 25, а это значит, что на всех оставшихся итерациях (то есть пока і не станет равна 10) будет срабатывать continue, так как на всех этих оставшихся итерациях переменная a равна 25, что также видно в выводе.',
      name: 'JavaBreakContinue10',
      desc: '',
      args: [],
    );
  }

  /// `BufferedInputStream, BufferedOutputStream - чтение байтового потока и запись в байтовый поток с добавлением буфера для улучшения производительности. \n\nКласс обертка для InputStream с буферизацией. \n\nБлагодаря буферизации потоки, которые переданы в конструктор BufferedInputStream будут читать данные из буфера маленькими порциями, а буфер, чтобы сэкономить время и силы, читает их из потока источника большими порциями.\n\nПример программы:                                `
  String get JavaBuffStr1 {
    return Intl.message(
      'BufferedInputStream, BufferedOutputStream - чтение байтового потока и запись в байтовый поток с добавлением буфера для улучшения производительности. \n\nКласс обертка для InputStream с буферизацией. \n\nБлагодаря буферизации потоки, которые переданы в конструктор BufferedInputStream будут читать данные из буфера маленькими порциями, а буфер, чтобы сэкономить время и силы, читает их из потока источника большими порциями.\n\nПример программы:                                ',
      name: 'JavaBuffStr1',
      desc: '',
      args: [],
    );
  }

  /// `Вывод                                                                                           `
  String get JavaBuffStr2 {
    return Intl.message(
      'Вывод                                                                                           ',
      name: 'JavaBuffStr2',
      desc: '',
      args: [],
    );
  }

  /// `Реализация Callable`
  String get JavaCallable1 {
    return Intl.message(
      'Реализация Callable',
      name: 'JavaCallable1',
      desc: '',
      args: [],
    );
  }

  /// `Последний вариант того как можно создать класс потока это реализовать Callable.\n\nCallable - как Runnable, только вместо run() - call(), который может возвращать значение, то есть благодаря call поток может вернуть значение.\n\nFutureTask - для взаимодействия с потоками. Он для получения результата выполнения потока (того, что вернет call), еще имеет методы проверки состояния потока.\n\nС помощью метода get() класса FutureTask можно получить результат выполнения потока когда он завершит свое выполнение. \nget() блокирует поток в котором он был вызван пока не выполниться поток переданный в объект FutureTask.\n\nИз также важных методов - с помощью isDone() можем проверить завершился ли уже поток или еще нет.\n\nПример программы:                                                  `
  String get JavaCallable2 {
    return Intl.message(
      'Последний вариант того как можно создать класс потока это реализовать Callable.\n\nCallable - как Runnable, только вместо run() - call(), который может возвращать значение, то есть благодаря call поток может вернуть значение.\n\nFutureTask - для взаимодействия с потоками. Он для получения результата выполнения потока (того, что вернет call), еще имеет методы проверки состояния потока.\n\nС помощью метода get() класса FutureTask можно получить результат выполнения потока когда он завершит свое выполнение. \nget() блокирует поток в котором он был вызван пока не выполниться поток переданный в объект FutureTask.\n\nИз также важных методов - с помощью isDone() можем проверить завершился ли уже поток или еще нет.\n\nПример программы:                                                  ',
      name: 'JavaCallable2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCallable3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCallable3',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, get остановил мейн пока выполнялся поток t и когда t выполнился мейн снова запустился и вывел Counter: 5`
  String get JavaCallable4 {
    return Intl.message(
      'Как видим, get остановил мейн пока выполнялся поток t и когда t выполнился мейн снова запустился и вывел Counter: 5',
      name: 'JavaCallable4',
      desc: '',
      args: [],
    );
  }

  /// `Второй метод Object это метод clone, который клонирует объект. \n\nПроисходит копирование всех полей клонируемого объекта в новый объект-клон. \n\nНо по умолчанию методом clone в новый объект копируются только примитивные поля объекта, а ссылочные нет, поэтому clone тоже нужно переопределять.\n\nВ Java управление объектами осуществляется с помощью ссылочных переменных, и нет оператора для фактического копирования объекта, поэтому и существует clone.`
  String get JavaClone1 {
    return Intl.message(
      'Второй метод Object это метод clone, который клонирует объект. \n\nПроисходит копирование всех полей клонируемого объекта в новый объект-клон. \n\nНо по умолчанию методом clone в новый объект копируются только примитивные поля объекта, а ссылочные нет, поэтому clone тоже нужно переопределять.\n\nВ Java управление объектами осуществляется с помощью ссылочных переменных, и нет оператора для фактического копирования объекта, поэтому и существует clone.',
      name: 'JavaClone1',
      desc: '',
      args: [],
    );
  }

  /// `Переопределение Clone`
  String get JavaClone2 {
    return Intl.message(
      'Переопределение Clone',
      name: 'JavaClone2',
      desc: '',
      args: [],
    );
  }

  /// `Напрямую вызвать clone у какого либо объекта в main нельзя, так как метод clone внутри Object объявлен protected.\n\nПоэтому для того чтобы вызвать clone у какого либо объекта его всегда нужно переопределять.\n\nТо есть имеется ввиду, что даже чтобы использовать стандартную реализацию clone, которая копирует только примитивные поля всё равно нужно сделать минимальное переопределение clone, как это сделано в классе SomeClass ниже.\n\nСоздадим два класса в которых будем переопределять clone.\n\nВсе классы, которые переопределяют clone должны реализовывать интерфейс Cloneable. То есть видим ниже в примере программы implements Cloneable\n\nПример программы:                                                  `
  String get JavaClone3 {
    return Intl.message(
      'Напрямую вызвать clone у какого либо объекта в main нельзя, так как метод clone внутри Object объявлен protected.\n\nПоэтому для того чтобы вызвать clone у какого либо объекта его всегда нужно переопределять.\n\nТо есть имеется ввиду, что даже чтобы использовать стандартную реализацию clone, которая копирует только примитивные поля всё равно нужно сделать минимальное переопределение clone, как это сделано в классе SomeClass ниже.\n\nСоздадим два класса в которых будем переопределять clone.\n\nВсе классы, которые переопределяют clone должны реализовывать интерфейс Cloneable. То есть видим ниже в примере программы implements Cloneable\n\nПример программы:                                                  ',
      name: 'JavaClone3',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaClone4 {
    return Intl.message(
      'Вывод:',
      name: 'JavaClone4',
      desc: '',
      args: [],
    );
  }

  /// `Однострочный комментарий`
  String get JavaComments1 {
    return Intl.message(
      'Однострочный комментарий',
      name: 'JavaComments1',
      desc: '',
      args: [],
    );
  }

  /// `Рассмотрим комментарии. \n\nКомментарии никак не влияют на ход выполнения программы, они лишь нужны чтобы, как можно догадаться, комментировать код.\n\nОднострочный комментарий пишется используя двойной слеш - //.\nКак можно догадаться из названия, это комментарий в одну строчку кода. В примере ниже у нас два однострочных комментария.`
  String get JavaComments2 {
    return Intl.message(
      'Рассмотрим комментарии. \n\nКомментарии никак не влияют на ход выполнения программы, они лишь нужны чтобы, как можно догадаться, комментировать код.\n\nОднострочный комментарий пишется используя двойной слеш - //.\nКак можно догадаться из названия, это комментарий в одну строчку кода. В примере ниже у нас два однострочных комментария.',
      name: 'JavaComments2',
      desc: '',
      args: [],
    );
  }

  /// `Их в программе может быть сколько угодно и запуск вышеприведенной программы ничем не будет отличаться от запуска такой же без комментариев.`
  String get JavaComments3 {
    return Intl.message(
      'Их в программе может быть сколько угодно и запуск вышеприведенной программы ничем не будет отличаться от запуска такой же без комментариев.',
      name: 'JavaComments3',
      desc: '',
      args: [],
    );
  }

  /// `Многострочный комментарий`
  String get JavaComments4 {
    return Intl.message(
      'Многострочный комментарий',
      name: 'JavaComments4',
      desc: '',
      args: [],
    );
  }

  /// `Также комментарии можно писать вот так:\n/* Какой-то комментарий */. \n\nЭто многострочный комментарий. \n\n/* - открывает комментарий\n*/ - закрывает комментарий\n\nОдин однострочный комментарий занимает только одну строку. Один же многострочный комментарий может занимать много строк. Комментарий внутри /* */ можно распределить на много строк. Внизу пример одного многострочного комментария.\nНапример:`
  String get JavaComments5 {
    return Intl.message(
      'Также комментарии можно писать вот так:\n/* Какой-то комментарий */. \n\nЭто многострочный комментарий. \n\n/* - открывает комментарий\n*/ - закрывает комментарий\n\nОдин однострочный комментарий занимает только одну строку. Один же многострочный комментарий может занимать много строк. Комментарий внутри /* */ можно распределить на много строк. Внизу пример одного многострочного комментария.\nНапример:',
      name: 'JavaComments5',
      desc: '',
      args: [],
    );
  }

  /// `На комментарии по ходу курса обращайте внимание в них зачастую будет всё основное пояснение программы.`
  String get JavaComments6 {
    return Intl.message(
      'На комментарии по ходу курса обращайте внимание в них зачастую будет всё основное пояснение программы.',
      name: 'JavaComments6',
      desc: '',
      args: [],
    );
  }

  /// `Конструктор`
  String get JavaConstr1 {
    return Intl.message(
      'Конструктор',
      name: 'JavaConstr1',
      desc: '',
      args: [],
    );
  }

  /// `У класса может быть специальный метод без возвращаемого значения и который имеет то же самое имя, что и класс. \n\nЭтот метод называется конструктором.\n\nОн нужен чтобы при создании объекта класса можно было выполнить какие-то действия, например сразу при создании объекта присвоить его полям значения.           `
  String get JavaConstr2 {
    return Intl.message(
      'У класса может быть специальный метод без возвращаемого значения и который имеет то же самое имя, что и класс. \n\nЭтот метод называется конструктором.\n\nОн нужен чтобы при создании объекта класса можно было выполнить какие-то действия, например сразу при создании объекта присвоить его полям значения.           ',
      name: 'JavaConstr2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaConstr3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaConstr3',
      desc: '',
      args: [],
    );
  }

  /// `CountDownLatch - если нам нужно чтобы какой-то поток ждал пока не выполняться какое-то количество потоков.\n\nВ примере ниже мейн останавливает свою работу с помощью await и когда в потоках вызовется countDown три раза, мейн продолжает свою работу.\n\nПример программы:                                                  `
  String get JavaCountDownLatch1 {
    return Intl.message(
      'CountDownLatch - если нам нужно чтобы какой-то поток ждал пока не выполняться какое-то количество потоков.\n\nВ примере ниже мейн останавливает свою работу с помощью await и когда в потоках вызовется countDown три раза, мейн продолжает свою работу.\n\nПример программы:                                                  ',
      name: 'JavaCountDownLatch1',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCountDownLatch2 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCountDownLatch2',
      desc: '',
      args: [],
    );
  }

  /// `Из консоли видно, что три потока завершили свое выполнение и сразу после этого ожил мейн.`
  String get JavaCountDownLatch3 {
    return Intl.message(
      'Из консоли видно, что три потока завершили свое выполнение и сразу после этого ожил мейн.',
      name: 'JavaCountDownLatch3',
      desc: '',
      args: [],
    );
  }

  /// `Цикл while`
  String get JavaCycles1 {
    return Intl.message(
      'Цикл while',
      name: 'JavaCycles1',
      desc: '',
      args: [],
    );
  }

  /// `Рассмотрим циклы.\n\nЦикл нужен чтобы повторять какое-о действие или набор действий какое-то количество раз.\n\nЕсть три вида циклов for, while и do..while.\n\nНачнем с while.\n\nПоясним на примере.`
  String get JavaCycles2 {
    return Intl.message(
      'Рассмотрим циклы.\n\nЦикл нужен чтобы повторять какое-о действие или набор действий какое-то количество раз.\n\nЕсть три вида циклов for, while и do..while.\n\nНачнем с while.\n\nПоясним на примере.',
      name: 'JavaCycles2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCycles3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCycles3',
      desc: '',
      args: [],
    );
  }

  /// `Каждую итерацию цикла от A отнимается 1 и когда A становиться 15 (что значит, что A уже будет равна b, а это в свою очередь значит, что выражение a!=b\tуже будет ложью) цикл остановиться.`
  String get JavaCycles4 {
    return Intl.message(
      'Каждую итерацию цикла от A отнимается 1 и когда A становиться 15 (что значит, что A уже будет равна b, а это в свою очередь значит, что выражение a!=b\tуже будет ложью) цикл остановиться.',
      name: 'JavaCycles4',
      desc: '',
      args: [],
    );
  }

  /// `Цикл for`
  String get JavaCycles5 {
    return Intl.message(
      'Цикл for',
      name: 'JavaCycles5',
      desc: '',
      args: [],
    );
  }

  /// `Также есть цикл for.`
  String get JavaCycles6 {
    return Intl.message(
      'Также есть цикл for.',
      name: 'JavaCycles6',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, в программе ниже в скобочках у цикла три выражения разделены точкой с запятой.\n\nПоясним каждое из этих выражений. \n\nПервое выполняется единожды перед первой итерацией цикла for. В нашем случае первое, что происходит когда цикл for запускается, это создание целочисленной переменной i.\n\nВторое выражение, как у нас было в while, при невыполнении которого цикл завершиться.\n\nТретье выражение выполняется в конце каждой итерации цикла.`
  String get JavaCycles7 {
    return Intl.message(
      'Как видим, в программе ниже в скобочках у цикла три выражения разделены точкой с запятой.\n\nПоясним каждое из этих выражений. \n\nПервое выполняется единожды перед первой итерацией цикла for. В нашем случае первое, что происходит когда цикл for запускается, это создание целочисленной переменной i.\n\nВторое выражение, как у нас было в while, при невыполнении которого цикл завершиться.\n\nТретье выражение выполняется в конце каждой итерации цикла.',
      name: 'JavaCycles7',
      desc: '',
      args: [],
    );
  }

  /// `Пример программы:`
  String get JavaCycles8 {
    return Intl.message(
      'Пример программы:',
      name: 'JavaCycles8',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCycles9 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCycles9',
      desc: '',
      args: [],
    );
  }

  /// `То есть переменная i будет каждую итерацию цикла увеличиваться на 1 и пока она не станет равна 10 цикл будет продолжать работать.\nТо есть будет совершено 10 итераций цикла for. \nИ на последней итерации цикла а будет равно 21.\nСтоит упомянуть, что созданная нами переменная і при выходе из последнего цикла удаляется, она живет только в цикле.\n\nЭто самый часто используемый цикл, так как на место этих трех выражений можно ставить что угодно, что очень гибко и удобно.`
  String get JavaCycles10 {
    return Intl.message(
      'То есть переменная i будет каждую итерацию цикла увеличиваться на 1 и пока она не станет равна 10 цикл будет продолжать работать.\nТо есть будет совершено 10 итераций цикла for. \nИ на последней итерации цикла а будет равно 21.\nСтоит упомянуть, что созданная нами переменная і при выходе из последнего цикла удаляется, она живет только в цикле.\n\nЭто самый часто используемый цикл, так как на место этих трех выражений можно ставить что угодно, что очень гибко и удобно.',
      name: 'JavaCycles10',
      desc: '',
      args: [],
    );
  }

  /// `Цикл do...while`
  String get JavaCycles11 {
    return Intl.message(
      'Цикл do...while',
      name: 'JavaCycles11',
      desc: '',
      args: [],
    );
  }

  /// `Также есть цикл do...while\n\nРазницы с просто while почти никакой нету, только, как можно увидеть ниже в программе, условие проверяется в конце, а это значит, что одна итерация цикла так или иначе выполниться.`
  String get JavaCycles12 {
    return Intl.message(
      'Также есть цикл do...while\n\nРазницы с просто while почти никакой нету, только, как можно увидеть ниже в программе, условие проверяется в конце, а это значит, что одна итерация цикла так или иначе выполниться.',
      name: 'JavaCycles12',
      desc: '',
      args: [],
    );
  }

  /// `Пример программы:`
  String get JavaCycles13 {
    return Intl.message(
      'Пример программы:',
      name: 'JavaCycles13',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCycles14 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCycles14',
      desc: '',
      args: [],
    );
  }

  /// `То есть в отличии от просто while в цикле do...while сначала выполняется код в {} потом проверка условия.     \n\nИногда этот цикл бывает полезен. Но он самый не популярный и его вы будете встречать очень редко.`
  String get JavaCycles15 {
    return Intl.message(
      'То есть в отличии от просто while в цикле do...while сначала выполняется код в {} потом проверка условия.     \n\nИногда этот цикл бывает полезен. Но он самый не популярный и его вы будете встречать очень редко.',
      name: 'JavaCycles15',
      desc: '',
      args: [],
    );
  }

  /// `CyclicBarrier - потоки зависают друг за другом в месте вызова await, когда зависло необходимое количество потоков зависнувшие потоки развисают и запускается какой-то другой один поток в котором можно что-то сделать, например использовать то что выполнялось в зависавших потоках.\n\nВ примере ниже мы создаем переменную volatile и потоки добавляют к ней 1, потом в месте await останавливаются и когда зависнет указанное в CyclicBarrier количество потоков потоки развисают и сразу после этого запускается метод run в классе Run. И в этом методе run класса Run будет использована эта ранее изменяемая зависающими потоками переменная.\n\nПример программы:                                                  `
  String get JavaCyclicBarrier1 {
    return Intl.message(
      'CyclicBarrier - потоки зависают друг за другом в месте вызова await, когда зависло необходимое количество потоков зависнувшие потоки развисают и запускается какой-то другой один поток в котором можно что-то сделать, например использовать то что выполнялось в зависавших потоках.\n\nВ примере ниже мы создаем переменную volatile и потоки добавляют к ней 1, потом в месте await останавливаются и когда зависнет указанное в CyclicBarrier количество потоков потоки развисают и сразу после этого запускается метод run в классе Run. И в этом методе run класса Run будет использована эта ранее изменяемая зависающими потоками переменная.\n\nПример программы:                                                  ',
      name: 'JavaCyclicBarrier1',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaCyclicBarrier2 {
    return Intl.message(
      'Вывод:',
      name: 'JavaCyclicBarrier2',
      desc: '',
      args: [],
    );
  }

  /// `Как видим шесть потоков остановили свою работу, потом запустился поток Run и вывел 6 и потом потоки продолжили работу.`
  String get JavaCyclicBarrier3 {
    return Intl.message(
      'Как видим шесть потоков остановили свою работу, потом запустился поток Run и вывел 6 и потом потоки продолжили работу.',
      name: 'JavaCyclicBarrier3',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь Многие-ко-Многим`
  String get JavaDBManyTo1 {
    return Intl.message(
      'Базы данных. Связь Многие-ко-Многим',
      name: 'JavaDBManyTo1',
      desc: '',
      args: [],
    );
  }

  /// `Далее рассмотрим тип связи Многие ко Многим. \n\nНапример. У каждого продукта есть много покупателей и у каждого покупателя есть много купленных продуктов.\n\nЯсное дело должно быть две таблицы - Продукты и Покупатели продуктов. И как-то нужно их связать. \n\nНо для начала следует увидеть одну таблицу в которой хранятся данные обеих только что упомянутых таблиц вместе.`
  String get JavaDBManyTo2 {
    return Intl.message(
      'Далее рассмотрим тип связи Многие ко Многим. \n\nНапример. У каждого продукта есть много покупателей и у каждого покупателя есть много купленных продуктов.\n\nЯсное дело должно быть две таблицы - Продукты и Покупатели продуктов. И как-то нужно их связать. \n\nНо для начала следует увидеть одну таблицу в которой хранятся данные обеих только что упомянутых таблиц вместе.',
      name: 'JavaDBManyTo2',
      desc: '',
      args: [],
    );
  }

  /// `Очевидно, что аттрибуты Имя покупателя, Имейл покупателя и Количество купленных товаров принадлежат не таблице продукты и их нужно отделить в отдельную таблицу Покупатели продуктов.\n\nТакже, как можно увидеть, повторяются в этой таблице и продукты и покупатели. \nНапример, Ricardo купил стол, лампу и утюг, но стол также купили Billy и Van. То есть повторение идет и покупателей и продуктов. \n\nПоэтому таблицы нужно разделить и связать их связью многие ко многим. \nПочему она многие ко многим думаю уже понятно - каждый покупатель может купить МНОГО разных продуктов и каждый продукт может быть куплен МНОГИМИ разными покупателями.`
  String get JavaDBManyTo3 {
    return Intl.message(
      'Очевидно, что аттрибуты Имя покупателя, Имейл покупателя и Количество купленных товаров принадлежат не таблице продукты и их нужно отделить в отдельную таблицу Покупатели продуктов.\n\nТакже, как можно увидеть, повторяются в этой таблице и продукты и покупатели. \nНапример, Ricardo купил стол, лампу и утюг, но стол также купили Billy и Van. То есть повторение идет и покупателей и продуктов. \n\nПоэтому таблицы нужно разделить и связать их связью многие ко многим. \nПочему она многие ко многим думаю уже понятно - каждый покупатель может купить МНОГО разных продуктов и каждый продукт может быть куплен МНОГИМИ разными покупателями.',
      name: 'JavaDBManyTo3',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь Многие-ко-Многим`
  String get JavaDBManyTo4 {
    return Intl.message(
      'Базы данных. Связь Многие-ко-Многим',
      name: 'JavaDBManyTo4',
      desc: '',
      args: [],
    );
  }

  /// `Итак разобьем же таблицу на две.                                `
  String get JavaDBManyTo5 {
    return Intl.message(
      'Итак разобьем же таблицу на две.                                ',
      name: 'JavaDBManyTo5',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь Многие-ко-Многим`
  String get JavaDBManyTo6 {
    return Intl.message(
      'Базы данных. Связь Многие-ко-Многим',
      name: 'JavaDBManyTo6',
      desc: '',
      args: [],
    );
  }

  /// `Как же нам теперь связать эти две таблицы? \n\nИтак подумаем. Что если, как мы уже делали ранее в таблице продукты, добавить аттрибут Внешний идентификатор покупателя в котором для каждого продукта будут храниться нужные идентификаторы покупателя из таблицы с покупателями.`
  String get JavaDBManyTo7 {
    return Intl.message(
      'Как же нам теперь связать эти две таблицы? \n\nИтак подумаем. Что если, как мы уже делали ранее в таблице продукты, добавить аттрибут Внешний идентификатор покупателя в котором для каждого продукта будут храниться нужные идентификаторы покупателя из таблицы с покупателями.',
      name: 'JavaDBManyTo7',
      desc: '',
      args: [],
    );
  }

  /// `Но подождите! Если мы посмотрим на исходную таблицу (ту которая на самом первом слайде урока), то стол же купил не только Billy, его купил и Van и Ricardo. Утюг также купил Billy и Ricardo. \nПолучается, что в таблице Продукты на рисунке выше нам нужно размножить стол и утюг. Так, ясное дело, нельзя, ведь нам же нужно минимизировать количество повторений данных в базе.`
  String get JavaDBManyTo8 {
    return Intl.message(
      'Но подождите! Если мы посмотрим на исходную таблицу (ту которая на самом первом слайде урока), то стол же купил не только Billy, его купил и Van и Ricardo. Утюг также купил Billy и Ricardo. \nПолучается, что в таблице Продукты на рисунке выше нам нужно размножить стол и утюг. Так, ясное дело, нельзя, ведь нам же нужно минимизировать количество повторений данных в базе.',
      name: 'JavaDBManyTo8',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь Многие-ко-Многим`
  String get JavaDBManyTo9 {
    return Intl.message(
      'Базы данных. Связь Многие-ко-Многим',
      name: 'JavaDBManyTo9',
      desc: '',
      args: [],
    );
  }

  /// `Давайте попробуем наоборот.                                                                         `
  String get JavaDBManyTo10 {
    return Intl.message(
      'Давайте попробуем наоборот.                                                                         ',
      name: 'JavaDBManyTo10',
      desc: '',
      args: [],
    );
  }

  /// `Очевидно та же самая ситуация. Только размноживать теперь придется покупателей.                                                               \nКак же быть?`
  String get JavaDBManyTo11 {
    return Intl.message(
      'Очевидно та же самая ситуация. Только размноживать теперь придется покупателей.                                                               \nКак же быть?',
      name: 'JavaDBManyTo11',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь Многие-ко-Многим`
  String get JavaDBManyTo12 {
    return Intl.message(
      'Базы данных. Связь Многие-ко-Многим',
      name: 'JavaDBManyTo12',
      desc: '',
      args: [],
    );
  }

  /// `Нужно создать третью таблицу. В этой таблице будут всего два аттрибута - Внешний идентификатор продукта и Внешний идентификатор покупателя. То есть очевидно, что в этих аттрибутах будут храниться ключи из других таблиц. И эти ключи разных таблиц будут сопоставлены друг другу, таким образом образуя связь меду двумя таблицами. \n\nПродемонстрируем это:`
  String get JavaDBManyTo13 {
    return Intl.message(
      'Нужно создать третью таблицу. В этой таблице будут всего два аттрибута - Внешний идентификатор продукта и Внешний идентификатор покупателя. То есть очевидно, что в этих аттрибутах будут храниться ключи из других таблиц. И эти ключи разных таблиц будут сопоставлены друг другу, таким образом образуя связь меду двумя таблицами. \n\nПродемонстрируем это:',
      name: 'JavaDBManyTo13',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, в первом столбике ключи из таблицы продукты, во втором же ключи из таблицы покупатели. \n\nВидим три единицы подряд в первом столбце.\nПолучается мы сопоставляем строку таблицы с продуктами где идентификатор 1 к строке покупателя с идентификатором 1, к строке покупателя с идентификатором 2 и к строке покупателя с идентификатором 3. То есть стол связан с Billy, Van и Ricardo. \n\nВо втором столбце видим три тройки подряд. То есть мы сопоставляем строку таблицы с покупателями где идентификатор 3 к строке продукта с идентификатором 1, к строке продукта с идентификатором 2 и к строке продукта с идентификатором 3. Ricardo связан со столом, лампой и утюгом. \n\nКак видим, множественная связь работает в обе стороны. С одной стороны может быть много столов и с другой стороны может быть много Ricardo.\nИ нам не приходиться, как в исходной таблице (той которая на первом слайде урока), дублировать строки целиком из обеих таблиц. Строки двух таблиц связывает отдельная таблица в которой всего два столбца с числовыми значениями.`
  String get JavaDBManyTo14 {
    return Intl.message(
      'Как видим, в первом столбике ключи из таблицы продукты, во втором же ключи из таблицы покупатели. \n\nВидим три единицы подряд в первом столбце.\nПолучается мы сопоставляем строку таблицы с продуктами где идентификатор 1 к строке покупателя с идентификатором 1, к строке покупателя с идентификатором 2 и к строке покупателя с идентификатором 3. То есть стол связан с Billy, Van и Ricardo. \n\nВо втором столбце видим три тройки подряд. То есть мы сопоставляем строку таблицы с покупателями где идентификатор 3 к строке продукта с идентификатором 1, к строке продукта с идентификатором 2 и к строке продукта с идентификатором 3. Ricardo связан со столом, лампой и утюгом. \n\nКак видим, множественная связь работает в обе стороны. С одной стороны может быть много столов и с другой стороны может быть много Ricardo.\nИ нам не приходиться, как в исходной таблице (той которая на первом слайде урока), дублировать строки целиком из обеих таблиц. Строки двух таблиц связывает отдельная таблица в которой всего два столбца с числовыми значениями.',
      name: 'JavaDBManyTo14',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany1 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany1',
      desc: '',
      args: [],
    );
  }

  /// `У каждого продукта может быть категория к которой он принадлежит. \n\nНапример, стол и стул относятся к категории мебель, а лампа, утюг и вентилятор к категории электроприборы.\n\nДавайте же добавим в таблицу из прошлого урока аттрибут Категория продукта. `
  String get JavaDBOneToMany2 {
    return Intl.message(
      'У каждого продукта может быть категория к которой он принадлежит. \n\nНапример, стол и стул относятся к категории мебель, а лампа, утюг и вентилятор к категории электроприборы.\n\nДавайте же добавим в таблицу из прошлого урока аттрибут Категория продукта. ',
      name: 'JavaDBOneToMany2',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, слово Электроприбор повторяется три раза, слово мебель два раза. \n\nА что если у нас в таблице будет больше электроприборов и больше мебели, то значит у нас в таблице будут повторяться эти два слова еще больше раз? \n\nИменно поэтому добавлять такой аттрибут, значения которого повторяются много раз, нельзя, так как мы с вами сейчас изучаем реляционную модель базы данных, которая определяет некоторые правила создания БД чтобы в ней практически вообще не было повторяющейся информации.`
  String get JavaDBOneToMany3 {
    return Intl.message(
      'Как видим, слово Электроприбор повторяется три раза, слово мебель два раза. \n\nА что если у нас в таблице будет больше электроприборов и больше мебели, то значит у нас в таблице будут повторяться эти два слова еще больше раз? \n\nИменно поэтому добавлять такой аттрибут, значения которого повторяются много раз, нельзя, так как мы с вами сейчас изучаем реляционную модель базы данных, которая определяет некоторые правила создания БД чтобы в ней практически вообще не было повторяющейся информации.',
      name: 'JavaDBOneToMany3',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany4 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany4',
      desc: '',
      args: [],
    );
  }

  /// `Так как же нам поступить с новым добавленным аттрибутом чтобы не было повторяющейся информации? \n\nВсё просто, нужно его вынести в отдельную таблицу и в ней уже будут храниться уникальные значения, а потом получившиеся две таблицы связать между собой. \n\nТо есть мы сейчас подошли к двум новым концепциям - идентификаторам (чаще называют ключами) и связям.\n\nРазбиваем таблицу. Вторая таблица будет иметь имя Категория продукта.`
  String get JavaDBOneToMany5 {
    return Intl.message(
      'Так как же нам поступить с новым добавленным аттрибутом чтобы не было повторяющейся информации? \n\nВсё просто, нужно его вынести в отдельную таблицу и в ней уже будут храниться уникальные значения, а потом получившиеся две таблицы связать между собой. \n\nТо есть мы сейчас подошли к двум новым концепциям - идентификаторам (чаще называют ключами) и связям.\n\nРазбиваем таблицу. Вторая таблица будет иметь имя Категория продукта.',
      name: 'JavaDBOneToMany5',
      desc: '',
      args: [],
    );
  }

  /// `Как видим теперь информация не повторяется.`
  String get JavaDBOneToMany6 {
    return Intl.message(
      'Как видим теперь информация не повторяется.',
      name: 'JavaDBOneToMany6',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany7 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany7',
      desc: '',
      args: [],
    );
  }

  /// `Теперь как же связать эти две таблицы? \n\nДля этого используется идентификатор(ключ). \n\nЧто же такое идентификатор?\nНапример, в таблице Продукт можно увидеть аттрибут Идентификатор продукта.\nИдентификатор в этой таблице идентифицирует продукт, по нему можно отличить один продукт от другого.\nСоответственно идентификаторы у продуктов в таблице обязательно должны быть разными чтобы по идентификатору можно было обратиться к одному конкретному продукту.\n\nИдентификаторы продуктов хранятся в отдельном столбце таблицы и ясное дело, как уже было сказано, в этом столбце не должно быть одинаковых значений.\n\nИдентификатор чаще всего это простое числовое значение. \n\nТаблице с категориями тоже добавим аттрибут Идентификатор категории, который будет хранить значения, которые однозначно идентифицируют ту или иную категорию.`
  String get JavaDBOneToMany8 {
    return Intl.message(
      'Теперь как же связать эти две таблицы? \n\nДля этого используется идентификатор(ключ). \n\nЧто же такое идентификатор?\nНапример, в таблице Продукт можно увидеть аттрибут Идентификатор продукта.\nИдентификатор в этой таблице идентифицирует продукт, по нему можно отличить один продукт от другого.\nСоответственно идентификаторы у продуктов в таблице обязательно должны быть разными чтобы по идентификатору можно было обратиться к одному конкретному продукту.\n\nИдентификаторы продуктов хранятся в отдельном столбце таблицы и ясное дело, как уже было сказано, в этом столбце не должно быть одинаковых значений.\n\nИдентификатор чаще всего это простое числовое значение. \n\nТаблице с категориями тоже добавим аттрибут Идентификатор категории, который будет хранить значения, которые однозначно идентифицируют ту или иную категорию.',
      name: 'JavaDBOneToMany8',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany9 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany9',
      desc: '',
      args: [],
    );
  }

  /// `Итак, теперь давайте уже непосредственно к тому как же связать таблицы. \n\nДля этого в таблице продукт нужно создать дополнительный столбец с внешним ключом, то есть ключ, который внешний, то есть из другой таблицы. Добавим этот столбец.`
  String get JavaDBOneToMany10 {
    return Intl.message(
      'Итак, теперь давайте уже непосредственно к тому как же связать таблицы. \n\nДля этого в таблице продукт нужно создать дополнительный столбец с внешним ключом, то есть ключ, который внешний, то есть из другой таблицы. Добавим этот столбец.',
      name: 'JavaDBOneToMany10',
      desc: '',
      args: [],
    );
  }

  /// `На картинке можно увидеть, что значения в столбце 'Внешний идентификатор категории' это значения из столбца 'Идентификатор категории' внешней таблицы категорий. То есть мы связали две таблицы по ключу в таблице с категориями. \n\nИ теперь нету дублирования Мебель или Электроприборы, дублируются только значения идентификаторов этих категорий. `
  String get JavaDBOneToMany11 {
    return Intl.message(
      'На картинке можно увидеть, что значения в столбце \'Внешний идентификатор категории\' это значения из столбца \'Идентификатор категории\' внешней таблицы категорий. То есть мы связали две таблицы по ключу в таблице с категориями. \n\nИ теперь нету дублирования Мебель или Электроприборы, дублируются только значения идентификаторов этих категорий. ',
      name: 'JavaDBOneToMany11',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany12 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany12',
      desc: '',
      args: [],
    );
  }

  /// `Кто-то может спросить, а какая разница дублируются категории или идентификаторы?\nРазница в том, что в таблице с категориями может быть не один аттрибут, а больше. \n\nНапример:`
  String get JavaDBOneToMany13 {
    return Intl.message(
      'Кто-то может спросить, а какая разница дублируются категории или идентификаторы?\nРазница в том, что в таблице с категориями может быть не один аттрибут, а больше. \n\nНапример:',
      name: 'JavaDBOneToMany13',
      desc: '',
      args: [],
    );
  }

  /// `Если бы мы не разделяли таблицы, то дублировалось бы уже два аттрибута: `
  String get JavaDBOneToMany14 {
    return Intl.message(
      'Если бы мы не разделяли таблицы, то дублировалось бы уже два аттрибута: ',
      name: 'JavaDBOneToMany14',
      desc: '',
      args: [],
    );
  }

  /// `Теперь профит от разделения таблиц должен быть очевиден.                   `
  String get JavaDBOneToMany15 {
    return Intl.message(
      'Теперь профит от разделения таблиц должен быть очевиден.                   ',
      name: 'JavaDBOneToMany15',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-ко-Многим`
  String get JavaDBOneToMany16 {
    return Intl.message(
      'Базы данных. Связь 1-ко-Многим',
      name: 'JavaDBOneToMany16',
      desc: '',
      args: [],
    );
  }

  /// `Рассмотренный тип связи называется 'Один ко многим'. \n\nВсего типов связей три и мы всех их разберем. \n\nОдин ко многим эта связь, потому что каждому продукту может соответствовать только ОДНА категория, но каждой категории может соответствовать МНОГО продуктов.\nТо есть у нас категории мебель (она одна) соответствует два продукта (их много), а категории электроприборы (она одна) соответствует три продукта (их много). `
  String get JavaDBOneToMany17 {
    return Intl.message(
      'Рассмотренный тип связи называется \'Один ко многим\'. \n\nВсего типов связей три и мы всех их разберем. \n\nОдин ко многим эта связь, потому что каждому продукту может соответствовать только ОДНА категория, но каждой категории может соответствовать МНОГО продуктов.\nТо есть у нас категории мебель (она одна) соответствует два продукта (их много), а категории электроприборы (она одна) соответствует три продукта (их много). ',
      name: 'JavaDBOneToMany17',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-к-1`
  String get JavaDBOneToOne1 {
    return Intl.message(
      'Базы данных. Связь 1-к-1',
      name: 'JavaDBOneToOne1',
      desc: '',
      args: [],
    );
  }

  /// `Последний вид связи - это Один к одному. \n\nЭтот вид связи Самый простой. \nКак понятно из названия, каждой строке одной таблицы соответствует только одна строка в другой. \n\nПочти не используется за редкими исключениями, так как очевидно, что соединение таблиц связанных таким образом в одну не приведет к дублированию данных. \n\nНо бывают случаи когда это бывает полезно. `
  String get JavaDBOneToOne2 {
    return Intl.message(
      'Последний вид связи - это Один к одному. \n\nЭтот вид связи Самый простой. \nКак понятно из названия, каждой строке одной таблицы соответствует только одна строка в другой. \n\nПочти не используется за редкими исключениями, так как очевидно, что соединение таблиц связанных таким образом в одну не приведет к дублированию данных. \n\nНо бывают случаи когда это бывает полезно. ',
      name: 'JavaDBOneToOne2',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-к-1`
  String get JavaDBOneToOne3 {
    return Intl.message(
      'Базы данных. Связь 1-к-1',
      name: 'JavaDBOneToOne3',
      desc: '',
      args: [],
    );
  }

  /// `Самый полезный случай - это когда мы хотим отделить из основной таблицы данные, которые относятся только к ее части. \n\nНапример, есть наша основная таблица Продукты.\nИ пусть в ней будет новый аттрибут - Бракованный товар. То есть например, все лампы из тех, что есть на складе оказались бракованными или все стулья, которые есть на складе оказались бракованными. То есть представим, что эти все стулья и лампы это какая-то конкретная их модель и эта модель выпускалась с браком, такое бывает. Тогда у них в этом столбце будет стоять true, то есть бракованные, если всё в порядке то false.`
  String get JavaDBOneToOne4 {
    return Intl.message(
      'Самый полезный случай - это когда мы хотим отделить из основной таблицы данные, которые относятся только к ее части. \n\nНапример, есть наша основная таблица Продукты.\nИ пусть в ней будет новый аттрибут - Бракованный товар. То есть например, все лампы из тех, что есть на складе оказались бракованными или все стулья, которые есть на складе оказались бракованными. То есть представим, что эти все стулья и лампы это какая-то конкретная их модель и эта модель выпускалась с браком, такое бывает. Тогда у них в этом столбце будет стоять true, то есть бракованные, если всё в порядке то false.',
      name: 'JavaDBOneToOne4',
      desc: '',
      args: [],
    );
  }

  /// `Так вот, очевидно, что у большей части продуктов в таблице будет стоять false. Так как такой массовый брак какого-то продукта это скорее редкость.`
  String get JavaDBOneToOne5 {
    return Intl.message(
      'Так вот, очевидно, что у большей части продуктов в таблице будет стоять false. Так как такой массовый брак какого-то продукта это скорее редкость.',
      name: 'JavaDBOneToOne5',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-к-1`
  String get JavaDBOneToOne6 {
    return Intl.message(
      'Базы данных. Связь 1-к-1',
      name: 'JavaDBOneToOne6',
      desc: '',
      args: [],
    );
  }

  /// `Для того чтобы нам не хранить информацию в таблице с продуктами о том, что с ними всё в порядке можно вынести информацию о том, что какие-то продукты бракованные в отдельную таблицу. `
  String get JavaDBOneToOne7 {
    return Intl.message(
      'Для того чтобы нам не хранить информацию в таблице с продуктами о том, что с ними всё в порядке можно вынести информацию о том, что какие-то продукты бракованные в отдельную таблицу. ',
      name: 'JavaDBOneToOne7',
      desc: '',
      args: [],
    );
  }

  /// `И ясное дело в этой новой таблице, как видим, намного меньше записей, чем если бы информация о браке хранилась в формате столбца в таблице с продуктами, так как уже было сказано в ней нет информации о том, что какие-то продукты не бракованные. То есть, как видим, в ней нету false, эту информацию в этой таблице хранить незачем, поскольку если у какого-то продукта нету связанной строки в таблице барка, это само по себе значит, что продукт не бракованный. То есть у стола, утюга и вентилятора нету связи с таблицей брака и это само по себе значит, что с этими продуктами всё в порядке.`
  String get JavaDBOneToOne8 {
    return Intl.message(
      'И ясное дело в этой новой таблице, как видим, намного меньше записей, чем если бы информация о браке хранилась в формате столбца в таблице с продуктами, так как уже было сказано в ней нет информации о том, что какие-то продукты не бракованные. То есть, как видим, в ней нету false, эту информацию в этой таблице хранить незачем, поскольку если у какого-то продукта нету связанной строки в таблице барка, это само по себе значит, что продукт не бракованный. То есть у стола, утюга и вентилятора нету связи с таблицей брака и это само по себе значит, что с этими продуктами всё в порядке.',
      name: 'JavaDBOneToOne8',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Связь 1-к-1`
  String get JavaDBOneToOne9 {
    return Intl.message(
      'Базы данных. Связь 1-к-1',
      name: 'JavaDBOneToOne9',
      desc: '',
      args: [],
    );
  }

  /// `Второй случай использования связи Один к одному - зто если, например, в таблице слишком много столбцов, то чтобы ее немного уменьшить можно некоторые столбцы вынести в отдельные таблицы.\n\nТретий случай - это когда у нас, например, есть таблица с продуктами и у продуктов появляется какой-то новый ВРЕМЕННЫЙ аттрибут. То есть мы точно знаем, что этот столбец мы со временем удалим из таблицы. И создавать новый столбец в основной таблице не всегда бывает удобно, легче создать отдельную таблицу чтобы потом с легкостью ее удалить.\n\nЧетвертый случай - это из соображений безопасности. То есть если злоумышленник получит доступ к основной таблице, а в ней есть какие-то очень секретные аттрибуты, то он может просто пройтись по строкам таблицы и выбрать эти все секретные данные. очевидно безопаснее было бы хранить эти секретные данные в виде отдельных таблиц чтобы хацкер не смог получить их всех скопом.\n\nВСё!! С этой информацией вы сможете спроектировать реляционную БД любой сложности.`
  String get JavaDBOneToOne10 {
    return Intl.message(
      'Второй случай использования связи Один к одному - зто если, например, в таблице слишком много столбцов, то чтобы ее немного уменьшить можно некоторые столбцы вынести в отдельные таблицы.\n\nТретий случай - это когда у нас, например, есть таблица с продуктами и у продуктов появляется какой-то новый ВРЕМЕННЫЙ аттрибут. То есть мы точно знаем, что этот столбец мы со временем удалим из таблицы. И создавать новый столбец в основной таблице не всегда бывает удобно, легче создать отдельную таблицу чтобы потом с легкостью ее удалить.\n\nЧетвертый случай - это из соображений безопасности. То есть если злоумышленник получит доступ к основной таблице, а в ней есть какие-то очень секретные аттрибуты, то он может просто пройтись по строкам таблицы и выбрать эти все секретные данные. очевидно безопаснее было бы хранить эти секретные данные в виде отдельных таблиц чтобы хацкер не смог получить их всех скопом.\n\nВСё!! С этой информацией вы сможете спроектировать реляционную БД любой сложности.',
      name: 'JavaDBOneToOne10',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Азы`
  String get JavaDBBasics1 {
    return Intl.message(
      'Базы данных. Азы',
      name: 'JavaDBBasics1',
      desc: '',
      args: [],
    );
  }

  /// `Что такое база данных? \n\nДумаю можно догадаться, что это хранилище в котором хранятся данные.\n\nНаиболее удобный вариант хранения данных в БД в виде таблиц. \nКонкретная таблица БД хранит в себе данные какой-либо конкретной сущности.\n\nНапример, есть таблица сущности 'Продукт'. В этой таблице могут храниться много разных продуктов (там стол, стул, лампа и т.д.).\n\nКаждая строка таблицы хранит характеристики конкретного продукта, то есть одного из этих многих продуктов. \nТо есть, например, одна строка таблицы хранит данные о лампе, другая о стуле и т.д. \n\nСтроки таблицы разбиты на ячейки. \nВ каждой ячейке строки храниться конкретная какая-либо характеристика конкретного продукта (например стула). `
  String get JavaDBBasics2 {
    return Intl.message(
      'Что такое база данных? \n\nДумаю можно догадаться, что это хранилище в котором хранятся данные.\n\nНаиболее удобный вариант хранения данных в БД в виде таблиц. \nКонкретная таблица БД хранит в себе данные какой-либо конкретной сущности.\n\nНапример, есть таблица сущности \'Продукт\'. В этой таблице могут храниться много разных продуктов (там стол, стул, лампа и т.д.).\n\nКаждая строка таблицы хранит характеристики конкретного продукта, то есть одного из этих многих продуктов. \nТо есть, например, одна строка таблицы хранит данные о лампе, другая о стуле и т.д. \n\nСтроки таблицы разбиты на ячейки. \nВ каждой ячейке строки храниться конкретная какая-либо характеристика конкретного продукта (например стула). ',
      name: 'JavaDBBasics2',
      desc: '',
      args: [],
    );
  }

  /// `Базы данных. Азы`
  String get JavaDBBasics3 {
    return Intl.message(
      'Базы данных. Азы',
      name: 'JavaDBBasics3',
      desc: '',
      args: [],
    );
  }

  /// `Как и в вообще почти любой на свете таблице, ячейки строки таблицы формируются по столбцам и у этих столбцов таблицы зачастую есть имена. Есть имена и у столбцов таблиц в БД.\n\nНапример имя продукта, цена продукта, количество на складе или другое. То есть названия характеристик продукта по которым определяется в какую ячейку строки конкретного продукта значение какой характеристики помещать.\n\nСтолбцы таблицы принято называть аттрибутами, а строки кортежами.\n\nСейчас на примере таблицы Продукт будет понятнее.`
  String get JavaDBBasics4 {
    return Intl.message(
      'Как и в вообще почти любой на свете таблице, ячейки строки таблицы формируются по столбцам и у этих столбцов таблицы зачастую есть имена. Есть имена и у столбцов таблиц в БД.\n\nНапример имя продукта, цена продукта, количество на складе или другое. То есть названия характеристик продукта по которым определяется в какую ячейку строки конкретного продукта значение какой характеристики помещать.\n\nСтолбцы таблицы принято называть аттрибутами, а строки кортежами.\n\nСейчас на примере таблицы Продукт будет понятнее.',
      name: 'JavaDBBasics4',
      desc: '',
      args: [],
    );
  }

  /// `Видим аттрибуты продуктов таблицы (Идентификатор продукта, Наименование продукта, Цена продукта, Количество на складе).\nТакже видим пять кортежей (значит пять продуктов). \n\nЕсли мы представим, что это таблица базы данных используется в реальном магазине, то ясное дело если какой-нибудь из товаров купят, то его количество в таблице должно уменьшиться, если цена на него уменьшиться, то тоже таблица должна быть отредактирована. Редактирование таблицы совершается специальными командами о которых поговорим позже.`
  String get JavaDBBasics5 {
    return Intl.message(
      'Видим аттрибуты продуктов таблицы (Идентификатор продукта, Наименование продукта, Цена продукта, Количество на складе).\nТакже видим пять кортежей (значит пять продуктов). \n\nЕсли мы представим, что это таблица базы данных используется в реальном магазине, то ясное дело если какой-нибудь из товаров купят, то его количество в таблице должно уменьшиться, если цена на него уменьшиться, то тоже таблица должна быть отредактирована. Редактирование таблицы совершается специальными командами о которых поговорим позже.',
      name: 'JavaDBBasics5',
      desc: '',
      args: [],
    );
  }

  /// `DataInputStream DataOutputStream - чтение байтового потока и запись в байтовый поток в формате примитивных типов данных.\n\nПример программы:                                `
  String get JavaDataStream1 {
    return Intl.message(
      'DataInputStream DataOutputStream - чтение байтового потока и запись в байтовый поток в формате примитивных типов данных.\n\nПример программы:                                ',
      name: 'JavaDataStream1',
      desc: '',
      args: [],
    );
  }

  /// `После dos.writeDouble(56.45); в файл double.txt записывается число 56.45 (в формате double, поэтому оно так выглядит в файле).`
  String get JavaDataStream2 {
    return Intl.message(
      'После dos.writeDouble(56.45); в файл double.txt записывается число 56.45 (в формате double, поэтому оно так выглядит в файле).',
      name: 'JavaDataStream2',
      desc: '',
      args: [],
    );
  }

  /// `С помощью double inpStrDouble = dis.readDouble(); считываем из файла число, которое в формате double в переменную double.`
  String get JavaDataStream3 {
    return Intl.message(
      'С помощью double inpStrDouble = dis.readDouble(); считываем из файла число, которое в формате double в переменную double.',
      name: 'JavaDataStream3',
      desc: '',
      args: [],
    );
  }

  /// `Default методы в интерфейсах`
  String get JavaDefault1 {
    return Intl.message(
      'Default методы в интерфейсах',
      name: 'JavaDefault1',
      desc: '',
      args: [],
    );
  }

  /// `В java 8 всё же появилась возможность добавлять реализации методов в интерфейс. \n\nНужно в основном для того чтобы не было у классов реализующих интерфейс слишком много одинаковых реализаций абстрактных методов интерфейса.\n\nДо java 8 приходилось делать так:                                                `
  String get JavaDefault2 {
    return Intl.message(
      'В java 8 всё же появилась возможность добавлять реализации методов в интерфейс. \n\nНужно в основном для того чтобы не было у классов реализующих интерфейс слишком много одинаковых реализаций абстрактных методов интерфейса.\n\nДо java 8 приходилось делать так:                                                ',
      name: 'JavaDefault2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaDefault3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaDefault3',
      desc: '',
      args: [],
    );
  }

  /// `Default методы в интерфейсах`
  String get JavaDefault4 {
    return Intl.message(
      'Default методы в интерфейсах',
      name: 'JavaDefault4',
      desc: '',
      args: [],
    );
  }

  /// `Добавив дефолтные реализации gas и brake в интерфейс всем классам, которые реализуют Car больше не придется делать одинаковые реализации этих методов.\n\nПосле java 8:                                                `
  String get JavaDefault5 {
    return Intl.message(
      'Добавив дефолтные реализации gas и brake в интерфейс всем классам, которые реализуют Car больше не придется делать одинаковые реализации этих методов.\n\nПосле java 8:                                                ',
      name: 'JavaDefault5',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaDefault6 {
    return Intl.message(
      'Вывод:',
      name: 'JavaDefault6',
      desc: '',
      args: [],
    );
  }

  /// `Приложение, которое будет собираться в Docker Image`
  String get JavaDockerEx1 {
    return Intl.message(
      'Приложение, которое будет собираться в Docker Image',
      name: 'JavaDockerEx1',
      desc: '',
      args: [],
    );
  }

  /// `В этом уроке соберем простейшее Spring Boot приложение в Docker image, запустим его и загрузим на Docker Hub. \nЕго структура приведена ниже. В ней ничего особенного за исключением того, что в корне проекта добавлен файл с именем Dockerfile.`
  String get JavaDockerEx2 {
    return Intl.message(
      'В этом уроке соберем простейшее Spring Boot приложение в Docker image, запустим его и загрузим на Docker Hub. \nЕго структура приведена ниже. В ней ничего особенного за исключением того, что в корне проекта добавлен файл с именем Dockerfile.',
      name: 'JavaDockerEx2',
      desc: '',
      args: [],
    );
  }

  /// `В контроллере один простой обработчик, который возвращает строку Hello World!!!.`
  String get JavaDockerEx3 {
    return Intl.message(
      'В контроллере один простой обработчик, который возвращает строку Hello World!!!.',
      name: 'JavaDockerEx3',
      desc: '',
      args: [],
    );
  }

  /// `Настройка сборки`
  String get JavaDockerEx4 {
    return Intl.message(
      'Настройка сборки',
      name: 'JavaDockerEx4',
      desc: '',
      args: [],
    );
  }

  /// `Настраивается сборка Docker Image с помощью файла с названием Dockerfile, который необходимо создать в корне проекта, как можно было увидеть на предыдущем слайде.\n\nИтак. Было упомянуто, что всё, что нужно для запуска приложения докером должно уже быть в его Docker Image, чтобы не пришлось развертывать приложение и устанавливать кучу всего по отдельности. \nТак вот откуда же берется внутри image, который получается в результате сборки всё ПО, что будет запускать наше приложение (jdk например), все ПО, что будет скачивать зависимости для него (maven например) и т.д.? \nВсё просто, оно есть в интернете и когда производиться команда сборки приложения происходит скачивание его из интернета и помещение скачанного ПО в результирующий Docker Image. \nТакже при сборке приложения докер производит его настройку (например, закачку зависимостей) используя скачанное для этого ПО (например, докер скачал мавен и сразу производит им закачку зависимостей в собираемый Docker Image). При запуске же собранного Docker Image докер берет сказанное ПО для запуска и запускает им приложение(например, берет из скачанного jdk утилиту java и запускает ей spring-boot приложение).\nТак вот, то какое ПО будет скачиваться в результирующий Docker Image, то как им будет настраиваться или запускаться приложение внутри Docker Image как раз настраивается в Dockerfile.`
  String get JavaDockerEx5 {
    return Intl.message(
      'Настраивается сборка Docker Image с помощью файла с названием Dockerfile, который необходимо создать в корне проекта, как можно было увидеть на предыдущем слайде.\n\nИтак. Было упомянуто, что всё, что нужно для запуска приложения докером должно уже быть в его Docker Image, чтобы не пришлось развертывать приложение и устанавливать кучу всего по отдельности. \nТак вот откуда же берется внутри image, который получается в результате сборки всё ПО, что будет запускать наше приложение (jdk например), все ПО, что будет скачивать зависимости для него (maven например) и т.д.? \nВсё просто, оно есть в интернете и когда производиться команда сборки приложения происходит скачивание его из интернета и помещение скачанного ПО в результирующий Docker Image. \nТакже при сборке приложения докер производит его настройку (например, закачку зависимостей) используя скачанное для этого ПО (например, докер скачал мавен и сразу производит им закачку зависимостей в собираемый Docker Image). При запуске же собранного Docker Image докер берет сказанное ПО для запуска и запускает им приложение(например, берет из скачанного jdk утилиту java и запускает ей spring-boot приложение).\nТак вот, то какое ПО будет скачиваться в результирующий Docker Image, то как им будет настраиваться или запускаться приложение внутри Docker Image как раз настраивается в Dockerfile.',
      name: 'JavaDockerEx5',
      desc: '',
      args: [],
    );
  }

  /// `ПО для сборки с сайта Docker Hub.`
  String get JavaDockerEx6 {
    return Intl.message(
      'ПО для сборки с сайта Docker Hub.',
      name: 'JavaDockerEx6',
      desc: '',
      args: [],
    );
  }

  /// `Итак, из программ из интернета, которые нам нужны для сборки и запуска, нужно будет указать в Dockerfile мавен для загрузки зависимостей и сборки приложения в jar и jdk для запуска собранного мавеном jar файла приложения.\nИх можно найти на сайте Docker Hub. Там можно найти мавен репозиторий `
  String get JavaDockerEx7 {
    return Intl.message(
      'Итак, из программ из интернета, которые нам нужны для сборки и запуска, нужно будет указать в Dockerfile мавен для загрузки зависимостей и сборки приложения в jar и jdk для запуска собранного мавеном jar файла приложения.\nИх можно найти на сайте Docker Hub. Там можно найти мавен репозиторий ',
      name: 'JavaDockerEx7',
      desc: '',
      args: [],
    );
  }

  /// `и в тегах выбрать подходящую версию для нашего приложения.`
  String get JavaDockerEx8 {
    return Intl.message(
      'и в тегах выбрать подходящую версию для нашего приложения.',
      name: 'JavaDockerEx8',
      desc: '',
      args: [],
    );
  }

  /// `Таким же образом можем найти репозиторий jdk.`
  String get JavaDockerEx9 {
    return Intl.message(
      'Таким же образом можем найти репозиторий jdk.',
      name: 'JavaDockerEx9',
      desc: '',
      args: [],
    );
  }

  /// `И в его тегах тоже можно поискать подходящую версию jdk.`
  String get JavaDockerEx10 {
    return Intl.message(
      'И в его тегах тоже можно поискать подходящую версию jdk.',
      name: 'JavaDockerEx10',
      desc: '',
      args: [],
    );
  }

  /// `Очевидно, что ПО скачиваемое в Docker Image нашего спринг приложения тоже является Docker Image.`
  String get JavaDockerEx11 {
    return Intl.message(
      'Очевидно, что ПО скачиваемое в Docker Image нашего спринг приложения тоже является Docker Image.',
      name: 'JavaDockerEx11',
      desc: '',
      args: [],
    );
  }

  /// `Перейдем же к самому Dockerfile. \nСборка Docker Image происходит посредством последовательного выполнения команд прописанных в Dockerfile. Рассмотрим содержимое Dockerfile спринг приложения, которое мы будем собирать в Docker Image.`
  String get JavaDockerEx12 {
    return Intl.message(
      'Перейдем же к самому Dockerfile. \nСборка Docker Image происходит посредством последовательного выполнения команд прописанных в Dockerfile. Рассмотрим содержимое Dockerfile спринг приложения, которое мы будем собирать в Docker Image.',
      name: 'JavaDockerEx12',
      desc: '',
      args: [],
    );
  }

  /// `Сборка приложения в Docker Image`
  String get JavaDockerEx13 {
    return Intl.message(
      'Сборка приложения в Docker Image',
      name: 'JavaDockerEx13',
      desc: '',
      args: [],
    );
  }

  /// `Давайте в консоли перейдем в корневую папку спринг проекта, который мы собираемся собирать в Docker Image и собственно соберем его в Docker Image с помощью комманды: \n\ndocker build -t michaelshadrin/simple-spring-boot-app:version1 .\n\nЗдесь michaelshadrin/simple-spring-boot-app это название репозитория, который будет создан на сайте Docker Hub если мы захотим загрузить туда получившийся в результате этой команды Docker Image. Важно уточнить, что перед слешем в названии репозитория всегда указывается username аккаунта Docker Hub.\nversion1 это имя версии приложения собираемого в Docker Image и если загрузить получившийся Docker Image на Docker Hub, то в разделе Tags в репозитории michaelshadrin/simple-spring-boot-app можно будет увидеть Docker Image с названием version1.`
  String get JavaDockerEx14 {
    return Intl.message(
      'Давайте в консоли перейдем в корневую папку спринг проекта, который мы собираемся собирать в Docker Image и собственно соберем его в Docker Image с помощью комманды: \n\ndocker build -t michaelshadrin/simple-spring-boot-app:version1 .\n\nЗдесь michaelshadrin/simple-spring-boot-app это название репозитория, который будет создан на сайте Docker Hub если мы захотим загрузить туда получившийся в результате этой команды Docker Image. Важно уточнить, что перед слешем в названии репозитория всегда указывается username аккаунта Docker Hub.\nversion1 это имя версии приложения собираемого в Docker Image и если загрузить получившийся Docker Image на Docker Hub, то в разделе Tags в репозитории michaelshadrin/simple-spring-boot-app можно будет увидеть Docker Image с названием version1.',
      name: 'JavaDockerEx14',
      desc: '',
      args: [],
    );
  }

  /// `Процесс сборки может быть довольно долгим, так как в процессе сборки скачиваются jdk, maven, зависимости и другое.`
  String get JavaDockerEx15 {
    return Intl.message(
      'Процесс сборки может быть довольно долгим, так как в процессе сборки скачиваются jdk, maven, зависимости и другое.',
      name: 'JavaDockerEx15',
      desc: '',
      args: [],
    );
  }

  /// `Запуск Docker Image.`
  String get JavaDockerEx16 {
    return Intl.message(
      'Запуск Docker Image.',
      name: 'JavaDockerEx16',
      desc: '',
      args: [],
    );
  }

  /// `Давайте запустим получившийся Docker Image. Важно отметить, что перед этим необходимо включить на компьютере приложение Docker Desktop ссылка для скачивания которого давалась ранее.\nЗапускается получившийся Docker Image той самой, уже не раз упомянутой командой, которой запускается вообще любой Docker Image - командой docker container run. \nВыполним ее для запуска нашего Docker Image:`
  String get JavaDockerEx17 {
    return Intl.message(
      'Давайте запустим получившийся Docker Image. Важно отметить, что перед этим необходимо включить на компьютере приложение Docker Desktop ссылка для скачивания которого давалась ранее.\nЗапускается получившийся Docker Image той самой, уже не раз упомянутой командой, которой запускается вообще любой Docker Image - командой docker container run. \nВыполним ее для запуска нашего Docker Image:',
      name: 'JavaDockerEx17',
      desc: '',
      args: [],
    );
  }

  /// `В команде указывается пара портов -p 8081:8080. Первый порт - это порт компьютера на котором мы запускаем Docker Image, второй - это тот, что мы указывали в Dockerfile, то есть тот на котором запускается Docker Image в Docker Hub. \nПосле указания портов очевидно указывается название репозитория и имя конкретного Docker Image в нем, то есть имя версии.\n-d пишется в команде просто чтобы запущенный Docker Image не был привязан к консоли в которой он запускается. То есть, чтобы мы могли дальше использовать эту консоль после запуска Docker Image.\n\nИтак, Docker Image запущен, а значит и Spring boot приложение в нем тоже. Давайте обратимся к обработчику helloWorld этого приложения через порт компьютера 8081, который мы указывали в команде запуска Docker Image.`
  String get JavaDockerEx18 {
    return Intl.message(
      'В команде указывается пара портов -p 8081:8080. Первый порт - это порт компьютера на котором мы запускаем Docker Image, второй - это тот, что мы указывали в Dockerfile, то есть тот на котором запускается Docker Image в Docker Hub. \nПосле указания портов очевидно указывается название репозитория и имя конкретного Docker Image в нем, то есть имя версии.\n-d пишется в команде просто чтобы запущенный Docker Image не был привязан к консоли в которой он запускается. То есть, чтобы мы могли дальше использовать эту консоль после запуска Docker Image.\n\nИтак, Docker Image запущен, а значит и Spring boot приложение в нем тоже. Давайте обратимся к обработчику helloWorld этого приложения через порт компьютера 8081, который мы указывали в команде запуска Docker Image.',
      name: 'JavaDockerEx18',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, обработчик успешно вернул Hello World!!!, что значит, что сборка приложения в Docker Image и запуск этого Docker Image прошли успешно.`
  String get JavaDockerEx19 {
    return Intl.message(
      'Как видим, обработчик успешно вернул Hello World!!!, что значит, что сборка приложения в Docker Image и запуск этого Docker Image прошли успешно.',
      name: 'JavaDockerEx19',
      desc: '',
      args: [],
    );
  }

  /// `Запуск Image. Контейнеры`
  String get JavaDockerEx20 {
    return Intl.message(
      'Запуск Image. Контейнеры',
      name: 'JavaDockerEx20',
      desc: '',
      args: [],
    );
  }

  /// `Работающий, запущенный Docker Image называется контейнером. Запущенных, одновременно работающих докер контейнеров может быть много. Чтобы несколько Docker Image работали одновременно их нужно запустить на разных портах компьютера.\nДавайте запустим три контейнера одного и того же Docker Image на порте 8081, на порте 8082 и на порте 8083.`
  String get JavaDockerEx21 {
    return Intl.message(
      'Работающий, запущенный Docker Image называется контейнером. Запущенных, одновременно работающих докер контейнеров может быть много. Чтобы несколько Docker Image работали одновременно их нужно запустить на разных портах компьютера.\nДавайте запустим три контейнера одного и того же Docker Image на порте 8081, на порте 8082 и на порте 8083.',
      name: 'JavaDockerEx21',
      desc: '',
      args: [],
    );
  }

  /// `И ко всем можно будет иметь доступ через localhost по соответствующему порту.`
  String get JavaDockerEx22 {
    return Intl.message(
      'И ко всем можно будет иметь доступ через localhost по соответствующему порту.',
      name: 'JavaDockerEx22',
      desc: '',
      args: [],
    );
  }

  /// `Запуск Image. Контейнеры`
  String get JavaDockerEx23 {
    return Intl.message(
      'Запуск Image. Контейнеры',
      name: 'JavaDockerEx23',
      desc: '',
      args: [],
    );
  }

  /// `С помощью команды docker container list можно просмотреть все работающие контейнеры. `
  String get JavaDockerEx24 {
    return Intl.message(
      'С помощью команды docker container list можно просмотреть все работающие контейнеры. ',
      name: 'JavaDockerEx24',
      desc: '',
      args: [],
    );
  }

  /// `В результате этой команды можно увидеть разную информацию о контейнере, в том числе id запущенного контейнера. С помощью команды docker container stop можно остановить контейнер по этому id. Не обязательно писать id контейнера полностью, можно написать лишь его первые несколько символов.`
  String get JavaDockerEx25 {
    return Intl.message(
      'В результате этой команды можно увидеть разную информацию о контейнере, в том числе id запущенного контейнера. С помощью команды docker container stop можно остановить контейнер по этому id. Не обязательно писать id контейнера полностью, можно написать лишь его первые несколько символов.',
      name: 'JavaDockerEx25',
      desc: '',
      args: [],
    );
  }

  /// `Как видим, теперь работают только два контейнера, один мы остановили.`
  String get JavaDockerEx26 {
    return Intl.message(
      'Как видим, теперь работают только два контейнера, один мы остановили.',
      name: 'JavaDockerEx26',
      desc: '',
      args: [],
    );
  }

  /// `Загрузка Image на Docker Hub`
  String get JavaDockerEx27 {
    return Intl.message(
      'Загрузка Image на Docker Hub',
      name: 'JavaDockerEx27',
      desc: '',
      args: [],
    );
  }

  /// `Можно загрузить Docker Image, который мы собрали в Docker Hub. Сделать это можно через консоль посредством команды или через графический интерфейс приложения Docker Desktop. Сделаем это через Docker Desktop.\nВ приложении в разделе Images можно увидеть Image, который мы собирали. Чтобы загрузить его на Docker Hub достаточно лишь нажать на три точки и выбрать push. Начнется загрузка.`
  String get JavaDockerEx28 {
    return Intl.message(
      'Можно загрузить Docker Image, который мы собрали в Docker Hub. Сделать это можно через консоль посредством команды или через графический интерфейс приложения Docker Desktop. Сделаем это через Docker Desktop.\nВ приложении в разделе Images можно увидеть Image, который мы собирали. Чтобы загрузить его на Docker Hub достаточно лишь нажать на три точки и выбрать push. Начнется загрузка.',
      name: 'JavaDockerEx28',
      desc: '',
      args: [],
    );
  }

  /// `После загрузки в аккаунте с именем michaelshadrin (то что указывается до слеша в названии репозитория) должен появиться репозиторий michaelshadrin/simple-spring-boot-app, который будет содержать Image, который загружался.`
  String get JavaDockerEx29 {
    return Intl.message(
      'После загрузки в аккаунте с именем michaelshadrin (то что указывается до слеша в названии репозитория) должен появиться репозиторий michaelshadrin/simple-spring-boot-app, который будет содержать Image, который загружался.',
      name: 'JavaDockerEx29',
      desc: '',
      args: [],
    );
  }

  /// `В Tags этого репозитория видим image с названием version1.`
  String get JavaDockerEx30 {
    return Intl.message(
      'В Tags этого репозитория видим image с названием version1.',
      name: 'JavaDockerEx30',
      desc: '',
      args: [],
    );
  }

  /// `О пользе Docker`
  String get JavaDockerEx31 {
    return Intl.message(
      'О пользе Docker',
      name: 'JavaDockerEx31',
      desc: '',
      args: [],
    );
  }

  /// `Еще раз о преимуществах докера. \n\nПредставим себе ситуацию когда, например, вебсайт создают два человека - фронтенд часть один человек, а бэкенд часть другой. Фронтендер написал свою фронтенд часть и хочет протестировать ее как часть полноценного вебсайта. Для этого ему нужна вторая часть вебсайта - бэкенд. Тогда фронтендер может попросить у бэкендера image бэкенда, чтобы запускать этот image у себя на компьютере командой docker container run для тестирования взаимодействия разработанного фронта с беком. При этом фронтендер не занимаеться муторным развертыванием этого бэкенда у себя на компьютере, он может даже не знать на каком языке бэкендер его написал. Как видим, докер очень удобен при разработке приложений в команде. \nВообще всё может быть намного круче, приложение может состоять не из двух частей, а из множества микросервисов и каждый из них можно упаковать в отдельный image и всех их запускать одинаковой командой docker container run.\n`
  String get JavaDockerEx32 {
    return Intl.message(
      'Еще раз о преимуществах докера. \n\nПредставим себе ситуацию когда, например, вебсайт создают два человека - фронтенд часть один человек, а бэкенд часть другой. Фронтендер написал свою фронтенд часть и хочет протестировать ее как часть полноценного вебсайта. Для этого ему нужна вторая часть вебсайта - бэкенд. Тогда фронтендер может попросить у бэкендера image бэкенда, чтобы запускать этот image у себя на компьютере командой docker container run для тестирования взаимодействия разработанного фронта с беком. При этом фронтендер не занимаеться муторным развертыванием этого бэкенда у себя на компьютере, он может даже не знать на каком языке бэкендер его написал. Как видим, докер очень удобен при разработке приложений в команде. \nВообще всё может быть намного круче, приложение может состоять не из двух частей, а из множества микросервисов и каждый из них можно упаковать в отдельный image и всех их запускать одинаковой командой docker container run.\n',
      name: 'JavaDockerEx32',
      desc: '',
      args: [],
    );
  }

  /// `Подготовительные действия`
  String get JavaDockerHub1 {
    return Intl.message(
      'Подготовительные действия',
      name: 'JavaDockerHub1',
      desc: '',
      args: [],
    );
  }

  /// `Для начала работы с Docker необходимо его скачать и установить на компьютер по ссылке: https://www.docker.com/products/docker-desktop/\n\nТакже необходимо создать аккаунт на сайте Docker Hub по ссылке: https://hub.docker.com/signup.\n\nТам всё довольно стандартно и интуитивно, поэтому не будем заострять внимание.`
  String get JavaDockerHub2 {
    return Intl.message(
      'Для начала работы с Docker необходимо его скачать и установить на компьютер по ссылке: https://www.docker.com/products/docker-desktop/\n\nТакже необходимо создать аккаунт на сайте Docker Hub по ссылке: https://hub.docker.com/signup.\n\nТам всё довольно стандартно и интуитивно, поэтому не будем заострять внимание.',
      name: 'JavaDockerHub2',
      desc: '',
      args: [],
    );
  }

  /// `Что такое Docker Hub, Repository, Tag?`
  String get JavaDockerHub3 {
    return Intl.message(
      'Что такое Docker Hub, Repository, Tag?',
      name: 'JavaDockerHub3',
      desc: '',
      args: [],
    );
  }

  /// `Итак, как мы поняли, Docker image - это итоговый файл, который получается в результате сборки приложения с помощью Docker. \nЭтот файл содержит в себе приложение и все необходимые технологии для его запуска.\n\nКогда разработчик собрал докером приложение, он может загрузить получившийся Docker image в интернет на сайт Docker Hub. \nДопустим два приложения было собрано в Docker Image и загружено на Docker Hub. Тогда их можно увидеть на этом сайте:`
  String get JavaDockerHub4 {
    return Intl.message(
      'Итак, как мы поняли, Docker image - это итоговый файл, который получается в результате сборки приложения с помощью Docker. \nЭтот файл содержит в себе приложение и все необходимые технологии для его запуска.\n\nКогда разработчик собрал докером приложение, он может загрузить получившийся Docker image в интернет на сайт Docker Hub. \nДопустим два приложения было собрано в Docker Image и загружено на Docker Hub. Тогда их можно увидеть на этом сайте:',
      name: 'JavaDockerHub4',
      desc: '',
      args: [],
    );
  }

  /// `Теперь если какой-либо человек захочет запустить один из этих Docker image со своего докер аккаунта на своем компьютере командой docker container run -d -p 8081:8080 michaelshadrin/ecommerce-backend-app-docker:version1, то даже если на его компьютере нет запускаемого этой командой Docker Image произойдет скачивание этого Docker Image из интернета `
  String get JavaDockerHub5 {
    return Intl.message(
      'Теперь если какой-либо человек захочет запустить один из этих Docker image со своего докер аккаунта на своем компьютере командой docker container run -d -p 8081:8080 michaelshadrin/ecommerce-backend-app-docker:version1, то даже если на его компьютере нет запускаемого этой командой Docker Image произойдет скачивание этого Docker Image из интернета ',
      name: 'JavaDockerHub5',
      desc: '',
      args: [],
    );
  }

  /// `и после этого запуск этого Docker Image. Можно увидеть, что происходит Pulling from michaelshadrin/ecommerce-backend-app-docker, то есть скачивание ecommerce-backend-app-docker. Согласитесь довольно удобный механизм.`
  String get JavaDockerHub6 {
    return Intl.message(
      'и после этого запуск этого Docker Image. Можно увидеть, что происходит Pulling from michaelshadrin/ecommerce-backend-app-docker, то есть скачивание ecommerce-backend-app-docker. Согласитесь довольно удобный механизм.',
      name: 'JavaDockerHub6',
      desc: '',
      args: [],
    );
  }

  /// `Репозитории, теги на сайте Docker Hub`
  String get JavaDockerHub7 {
    return Intl.message(
      'Репозитории, теги на сайте Docker Hub',
      name: 'JavaDockerHub7',
      desc: '',
      args: [],
    );
  }

  /// `На прошлом слайде на картинке можно было увидеть два загруженных на сайт приложения собранных в Docker Image. Так вот, те два приложения на картинке, которые находятся на сайте правильно называть не приложениями, а репозиториями этих двух приложений. Называются они так, потому что каждый репозиторий хранит в себе не один Docker Image приложения, а много Docker Image разных версий одного и того же приложения. То есть если мы нажмем на один из репозиториев на сайте:`
  String get JavaDockerHub8 {
    return Intl.message(
      'На прошлом слайде на картинке можно было увидеть два загруженных на сайт приложения собранных в Docker Image. Так вот, те два приложения на картинке, которые находятся на сайте правильно называть не приложениями, а репозиториями этих двух приложений. Называются они так, потому что каждый репозиторий хранит в себе не один Docker Image приложения, а много Docker Image разных версий одного и того же приложения. То есть если мы нажмем на один из репозиториев на сайте:',
      name: 'JavaDockerHub8',
      desc: '',
      args: [],
    );
  }

  /// `то в разделе теги можно увидеть много Docker Image, которые являются разными версиями одного и того же приложения. То есть, ясное дело, разработчик по ходу разработки приложения будет собирать его в Docker Image не один раз, приложение будет изменяться и собирать новую его версию в Docker Image и загружать ее на сайт нужно будет не раз и все версии одного и того же приложения будут храниться в конкретном Docker Repositiry.\nЕще раз, конкретное приложение связано с конкретным Docker Repository для него. У нас было два репозитория для двух разных приложений.`
  String get JavaDockerHub9 {
    return Intl.message(
      'то в разделе теги можно увидеть много Docker Image, которые являются разными версиями одного и того же приложения. То есть, ясное дело, разработчик по ходу разработки приложения будет собирать его в Docker Image не один раз, приложение будет изменяться и собирать новую его версию в Docker Image и загружать ее на сайт нужно будет не раз и все версии одного и того же приложения будут храниться в конкретном Docker Repositiry.\nЕще раз, конкретное приложение связано с конкретным Docker Repository для него. У нас было два репозитория для двух разных приложений.',
      name: 'JavaDockerHub9',
      desc: '',
      args: [],
    );
  }

  /// `Docker. Что это?`
  String get JavaDockerInfo1 {
    return Intl.message(
      'Docker. Что это?',
      name: 'JavaDockerInfo1',
      desc: '',
      args: [],
    );
  }

  /// `С помощью докер можно запускать любые приложения реализованные любыми технологиями на любых языках программирования одной и той же командой.\nВот такой: \n\ndocker container run -d -p 8081:8080 michaelshadrin/simple-spring-boot-app:version1 .\n\n Ее содержимое разберем позже.\n\nДля того чтобы запустить приложение этой командой его нужно собрать в Docker Image.`
  String get JavaDockerInfo2 {
    return Intl.message(
      'С помощью докер можно запускать любые приложения реализованные любыми технологиями на любых языках программирования одной и той же командой.\nВот такой: \n\ndocker container run -d -p 8081:8080 michaelshadrin/simple-spring-boot-app:version1 .\n\n Ее содержимое разберем позже.\n\nДля того чтобы запустить приложение этой командой его нужно собрать в Docker Image.',
      name: 'JavaDockerInfo2',
      desc: '',
      args: [],
    );
  }

  /// `Docker. Что это?`
  String get JavaDockerInfo3 {
    return Intl.message(
      'Docker. Что это?',
      name: 'JavaDockerInfo3',
      desc: '',
      args: [],
    );
  }

  /// `Один раз собранное докером приложение в Docker image можно запустить даже на компьютере где не установлены различные необходимые программы, зависимости проекта, языки программирования на которых реализовано приложение.\nТо есть раньше для развертывания приложения на компьютере нужно было установить все необходимые технологии для его работы. \nНапример, для запуска spring boot приложения необходим jdk, maven, зависимости прописанные в pom. То есть нам приходилось отдельно скачивать jdk, потом отдельно скачивать maven вместе со spring boot приложением (поскольку maven встроен в spring boot приложение), потом отдельно скачивать зависимости проекта через этот maven. Это и называется развертывание приложения на компьютере. \nТеперь с докером, как мы уже поняли, всё намного проще. \n\nВнутри Docker Image получившимся в результате сборки приложения УЖЕ ЕСТЬ всё, что нужно для запуска этого приложения и любой человек может запустить приложение очень просто ранее упомянутой командой без муторного его развертывания.`
  String get JavaDockerInfo4 {
    return Intl.message(
      'Один раз собранное докером приложение в Docker image можно запустить даже на компьютере где не установлены различные необходимые программы, зависимости проекта, языки программирования на которых реализовано приложение.\nТо есть раньше для развертывания приложения на компьютере нужно было установить все необходимые технологии для его работы. \nНапример, для запуска spring boot приложения необходим jdk, maven, зависимости прописанные в pom. То есть нам приходилось отдельно скачивать jdk, потом отдельно скачивать maven вместе со spring boot приложением (поскольку maven встроен в spring boot приложение), потом отдельно скачивать зависимости проекта через этот maven. Это и называется развертывание приложения на компьютере. \nТеперь с докером, как мы уже поняли, всё намного проще. \n\nВнутри Docker Image получившимся в результате сборки приложения УЖЕ ЕСТЬ всё, что нужно для запуска этого приложения и любой человек может запустить приложение очень просто ранее упомянутой командой без муторного его развертывания.',
      name: 'JavaDockerInfo4',
      desc: '',
      args: [],
    );
  }

  /// `Docker. Что это?`
  String get JavaDockerInfo5 {
    return Intl.message(
      'Docker. Что это?',
      name: 'JavaDockerInfo5',
      desc: '',
      args: [],
    );
  }

  /// `Докер имеет стандартизированный способ сборки проекта. \nТо есть любые приложения использующие какие-угодно технологии имеют подобный способ сборки и в результате сборки имеют одинаковый итоговый формат. \nТакже Docker Image можно запускать одинаковым образом где угодно - на компьютере, в облаке или где-либо еще.`
  String get JavaDockerInfo6 {
    return Intl.message(
      'Докер имеет стандартизированный способ сборки проекта. \nТо есть любые приложения использующие какие-угодно технологии имеют подобный способ сборки и в результате сборки имеют одинаковый итоговый формат. \nТакже Docker Image можно запускать одинаковым образом где угодно - на компьютере, в облаке или где-либо еще.',
      name: 'JavaDockerInfo6',
      desc: '',
      args: [],
    );
  }

  /// `Equals`
  String get JavaEquals1 {
    return Intl.message(
      'Equals',
      name: 'JavaEquals1',
      desc: '',
      args: [],
    );
  }

  /// `Следующий метод Object - это equals. \n\n Возвращает boolean значение. \n\n equals по умолчанию проверяет только то, ссылаются ли две ссылки на один и тот же объект. \n\n Если нам нужно проверить не только это, а является ли содержимое одного объекта одинаковым с другим объектом, то его нужно переопределять.`
  String get JavaEquals2 {
    return Intl.message(
      'Следующий метод Object - это equals. \n\n Возвращает boolean значение. \n\n equals по умолчанию проверяет только то, ссылаются ли две ссылки на один и тот же объект. \n\n Если нам нужно проверить не только это, а является ли содержимое одного объекта одинаковым с другим объектом, то его нужно переопределять.',
      name: 'JavaEquals2',
      desc: '',
      args: [],
    );
  }

  /// `Переопределение Equals`
  String get JavaEquals5 {
    return Intl.message(
      'Переопределение Equals',
      name: 'JavaEquals5',
      desc: '',
      args: [],
    );
  }

  /// `Пример программы:                                                  `
  String get JavaEquals3 {
    return Intl.message(
      'Пример программы:                                                  ',
      name: 'JavaEquals3',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaEquals4 {
    return Intl.message(
      'Вывод:',
      name: 'JavaEquals4',
      desc: '',
      args: [],
    );
  }

  /// `Обработка исключений`
  String get JavaExceptions1 {
    return Intl.message(
      'Обработка исключений',
      name: 'JavaExceptions1',
      desc: '',
      args: [],
    );
  }

  /// `Если при работе Java приложения возникает ошибка(исключение) и обработка данной ошибки не предусмотрена в программе этого приложения, то приложение ОСТАНОВИТ свою работу и программисту, который запустил это приложение или пользователю, который использовал это приложение демонстрируется в виде большого и страшного StackTrace, что же с приложением случилось и какая ошибка произошла. Такой StackTrace мы все видели когда запускали программу с ошибкой. \n\nС помощью обработки ошибок можно сделать так чтобы приложение не останавливало свою работу даже если произошла ошибка, то есть можно сделать так чтобы пользователю например показалось сообщение "Невозможно сейчас выполнить данную операцию, потому что при выполнении данной операции произошла такая-то ошибка!" уже в виде красивого всплывающего окна вместо страшного StackTrace и главное, что приложение при этом продолжит работать. \n\nОбработка ошибок совершается с помощью try и catch. И еще finally можно иногда.`
  String get JavaExceptions2 {
    return Intl.message(
      'Если при работе Java приложения возникает ошибка(исключение) и обработка данной ошибки не предусмотрена в программе этого приложения, то приложение ОСТАНОВИТ свою работу и программисту, который запустил это приложение или пользователю, который использовал это приложение демонстрируется в виде большого и страшного StackTrace, что же с приложением случилось и какая ошибка произошла. Такой StackTrace мы все видели когда запускали программу с ошибкой. \n\nС помощью обработки ошибок можно сделать так чтобы приложение не останавливало свою работу даже если произошла ошибка, то есть можно сделать так чтобы пользователю например показалось сообщение "Невозможно сейчас выполнить данную операцию, потому что при выполнении данной операции произошла такая-то ошибка!" уже в виде красивого всплывающего окна вместо страшного StackTrace и главное, что приложение при этом продолжит работать. \n\nОбработка ошибок совершается с помощью try и catch. И еще finally можно иногда.',
      name: 'JavaExceptions2',
      desc: '',
      args: [],
    );
  }

  /// `Обработка исключений с помощью try catch`
  String get JavaExceptions3 {
    return Intl.message(
      'Обработка исключений с помощью try catch',
      name: 'JavaExceptions3',
      desc: '',
      args: [],
    );
  }

  /// `Если в коде try возникнет исключение указанное в круглых скобочках рядом с catch, то выполняется код в catch.\n\nПоясним на примере:                                                       `
  String get JavaExceptions4 {
    return Intl.message(
      'Если в коде try возникнет исключение указанное в круглых скобочках рядом с catch, то выполняется код в catch.\n\nПоясним на примере:                                                       ',
      name: 'JavaExceptions4',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaExceptions5 {
    return Intl.message(
      'Вывод:',
      name: 'JavaExceptions5',
      desc: '',
      args: [],
    );
  }

  /// `Throw и Throws`
  String get JavaExceptions6 {
    return Intl.message(
      'Throw и Throws',
      name: 'JavaExceptions6',
      desc: '',
      args: [],
    );
  }

  /// `По теме исключений еще нужно знать два ключевых слова throws и throw.\n\nПоясним на примере:                                                       `
  String get JavaExceptions7 {
    return Intl.message(
      'По теме исключений еще нужно знать два ключевых слова throws и throw.\n\nПоясним на примере:                                                       ',
      name: 'JavaExceptions7',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaExceptions8 {
    return Intl.message(
      'Вывод:',
      name: 'JavaExceptions8',
      desc: '',
      args: [],
    );
  }

  /// `Как видим при запуске программы происходит возбужденная нами ошибка.                                             `
  String get JavaExceptions9 {
    return Intl.message(
      'Как видим при запуске программы происходит возбужденная нами ошибка.                                             ',
      name: 'JavaExceptions9',
      desc: '',
      args: [],
    );
  }

  /// `Создание потока дорогостоящая операция.\n\nПоэтому можно вместо создания новых потоков переиспользовать те которые завершили свою работу.\n\nExecutorService помогает поддерживать пул потоков, то есть поддерживает выполнение некоторого фиксированного количества потоков, которые одновременно выполняются. \n\nТакже он назначает задачи этим потокам в этом пуле (в пуле всё время находятся те же самые потоки, это важно). \n\nОн также предоставляет возможность ставить задачи в очередь до тех пор, пока не появится свободный поток в пуле, если количество задач превышает количество доступных потоков.\n\nКак уже было сказано ExecutorService создает некоторый пул потоков. \nЕсли пул потоков имеет размер 10 то параллельно выполняться будет всего 10 потоков и как только один из 10 потоков завершит свою работу, он не создается заново, он перезапускается для выполнения уже другой задачи. \nТо есть потоки в пуле потоков не создаются заново, а переиспользуются.\n\nЭто частно может быть полезно в клиент-серверных программах. \nТо есть представим, что чтобы обработать один запрос клиента сервер создает отдельный поток. Когда серверной программой обрабатываются запросы клиентов, из-за большого количества потоков может увеличиваться время отклика (промежуток времени, который требуется серверу, чтобы обработать запрос извне). То есть требуется дополнительное время для постоянного создания нитей на сервере, что приводит к увеличению времени отклика и чтобы постоянно не создавались потоки на сервере дла обработки запросов, ExecutorService может помочь. То есть запросы будут выполняться в ExecutorService, в котором потоки переиспользуются для обработки запросов клиентов, и если в ExecutorService нет места, запросы становиться в очередь и будут ждать пока освободиться поток в ExecutorService.\n\nТакже это полезно тем, что в процессе может создаться лишь ограниченное количество потоков. Благодаря ExecutorService больше заданного в конструкторе количества потоков не создастся и ясное дело ExecutorService экономит ресурсы и время. Достигается желаемая нагрузка и не подвергаются опасности системные ресурсы.                                         `
  String get JavaExecutorService1 {
    return Intl.message(
      'Создание потока дорогостоящая операция.\n\nПоэтому можно вместо создания новых потоков переиспользовать те которые завершили свою работу.\n\nExecutorService помогает поддерживать пул потоков, то есть поддерживает выполнение некоторого фиксированного количества потоков, которые одновременно выполняются. \n\nТакже он назначает задачи этим потокам в этом пуле (в пуле всё время находятся те же самые потоки, это важно). \n\nОн также предоставляет возможность ставить задачи в очередь до тех пор, пока не появится свободный поток в пуле, если количество задач превышает количество доступных потоков.\n\nКак уже было сказано ExecutorService создает некоторый пул потоков. \nЕсли пул потоков имеет размер 10 то параллельно выполняться будет всего 10 потоков и как только один из 10 потоков завершит свою работу, он не создается заново, он перезапускается для выполнения уже другой задачи. \nТо есть потоки в пуле потоков не создаются заново, а переиспользуются.\n\nЭто частно может быть полезно в клиент-серверных программах. \nТо есть представим, что чтобы обработать один запрос клиента сервер создает отдельный поток. Когда серверной программой обрабатываются запросы клиентов, из-за большого количества потоков может увеличиваться время отклика (промежуток времени, который требуется серверу, чтобы обработать запрос извне). То есть требуется дополнительное время для постоянного создания нитей на сервере, что приводит к увеличению времени отклика и чтобы постоянно не создавались потоки на сервере дла обработки запросов, ExecutorService может помочь. То есть запросы будут выполняться в ExecutorService, в котором потоки переиспользуются для обработки запросов клиентов, и если в ExecutorService нет места, запросы становиться в очередь и будут ждать пока освободиться поток в ExecutorService.\n\nТакже это полезно тем, что в процессе может создаться лишь ограниченное количество потоков. Благодаря ExecutorService больше заданного в конструкторе количества потоков не создастся и ясное дело ExecutorService экономит ресурсы и время. Достигается желаемая нагрузка и не подвергаются опасности системные ресурсы.                                         ',
      name: 'JavaExecutorService1',
      desc: '',
      args: [],
    );
  }

  /// `Пример программы:                                                  `
  String get JavaExecutorService2 {
    return Intl.message(
      'Пример программы:                                                  ',
      name: 'JavaExecutorService2',
      desc: '',
      args: [],
    );
  }

  /// `Вывод:`
  String get JavaExecutorService3 {
    return Intl.message(
      'Вывод:',
      name: 'JavaExecutorService3',
      desc: '',
      args: [],
    );
  }

  /// `То есть ExecutorService нам нужен чтобы некоторое количество потоков, некоторое продолжительное время переиспользовалось для выполнения каких-либо задач.`
  String get JavaExecutorService4 {
    return Intl.message(
      'То есть ExecutorService нам нужен чтобы некоторое количество потоков, некоторое продолжительное время переиспользовалось для выполнения каких-либо задач.',
      name: 'JavaExecutorService4',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<S> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'en'),
      Locale.fromSubtags(languageCode: 'ru'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<S> load(Locale locale) => S.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
