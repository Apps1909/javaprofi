{
  "JavaIntroTitle": "What is Java, where is it used and is it promising?",
  "JavaIntro1": "Java это строго типизированный язык программирования общего назначения. \n\nПочему он строго типизированный мы узнаем позже, а то, что он общего назначения означает, что в принципе на нем можно писать всё что угодно. Но ясное дело всегда есть сферы в которых тот или иной язык показывает себя лучше остальных. На java в основном создаются Android приложения или Java EE приложения. Второе - это грубо говоря сайты. Данный курс сосредоточен на втором.  \n\nЕсли посмотреть на график самых популярных языков программирования в 2023 году, который представлен ниже, то очевидно, что Java является одним из самых популярных языков программирования сегодня (второй по популярности).",
  "JavaIntro2": "Поэтому на вопрос \"Стоит ли изучать Java?\" сегодня можно смело отвечать - ДА СТОИТ.",
  "JavaFirstProgramTitle": "Создадим первую java программу",
  "JavaFirstProgram": "Создадим и запустим первую Java программу.\n\nВ результате выполнения действий приведенных в прошлом уроке все библиотеки Java доступны на нашем компьютере и мы можем использовать их чтобы писать Java код и компилировать его.\nПишется Java код в фале с расширением .java. То есть, например, создадим: HelloWorld.java",
  "JavaFirstProgram2": "Зайдем в этот файл и добавим в него нашу первую программу, которая будет выводить 'Hello World!!!' в консоль.",
  "JavaFirstProgram3": "Здесь можно увидеть функцию main, класс с именем HelloWorld и вызов функции println.\nПока всё, что нужно знать об этой программе это что весь код в любом Java приложении запускается из функции main и функция main может быть только одна на всё приложение. Класс в котором находиться функция main должен иметь имя идентичное имени файла. \n\nФункция System.out.prontln() используется для вывода данных в консоль. То что будет выводиться помещаем в скобочки.\n\nЧто такое функции, классы и прочее будет разобрано потом.",
  "JavaFirstProgramTitle1": "Компиляция первой программы",
  "JavaFirstProgram4": "Итак в консоли с помощью команды cd переходим в нашу папку с нашей программой. \n\nДля этого сначала выделяем путь папки с программой:",
  "JavaFirstProgram5": "и вставляем его после cd в консоли чтобы перейти в эту папку.:",
  "JavaFirstProgram6": "Теперь в консоли мы в папке Programs.                                                                 ",
  "JavaFirstProgram7": "Теперь через консоль мы можем напрямую работать с файлами в ней, так как мы в нее перешли.\n\nКомпилируем файл HelloWorld.java с помощью javac.",
  "JavaFirstProgram8": "Как можно увидеть, в папке появился файлик с байт кодом, который можно запустить на нашем компьютере через java машину командой java.",
  "JavaFirstProgramTitle3": "Запустим первую java программу",
  "JavaFirstProgram9": "Запускаем программу и видим Hello World!!! в консоли. Все работает.",
  "JavaAbstractTitle": "Абстрактные классы",
  "JavaAbstract1": "Абстрактный класс - общий концепт чего-либо. \n\nЭто класс, который содержит в себе нереализованные методы (называются абстрактными методами), которые наследники должны реализовать. \n\nПод 'нереализованные' имеется ввиду, что такие методы только объявляются в абстрактном классе, то есть у них нет тела, то есть кода внутри {}.\n\nАбстрактные методы помечаются ключевым словом abstract.\n\nПриведем пример абстрактного класса. Например птица. Птица это общий концепт для любой птицы, будь-то воробей или попугай.\n\nАбстрактный класс птицы может иметь не только абстрактные методы, а и методы с реализацией.\nНапример. Любая птица имеет крылья. Махание крыльями примерно ОДИНАКОВОЕ у всех птиц (ну по крайней мере представим так). Соответственно можно создать в абстрактном классе не абстрактный, а обычный метод с реализацией для махания крыльями и все классы птиц, которые наследуют от абстрактного класса Птица будут по умолчанию пользоваться методом для махания крыльями из абстрактного класса.\n\nАбстрактный же метод в абстрактном классе Птица будет иметь смысл определить в таком случае:\nЛюбая птица издает какие-то звуки. Но в этом уже случае почти все птицы издают РАЗНЫЕ звуки. Значит в абстрактном классе Птица должен быть абстрактный метод для издавания звуков, который наследующие от этого абстрактного класса птицы обязаны переопределить.\n\nТо есть суть в том, что если мы знаем, что у класса, который мы создаем будут наследники и у всех них будет метод, который будет выполнять одно и то же действие (например, издавание звуков у птиц), но результат этого метода у всех наследников будет разным (разные звуки), то есть смысл объявить создаваемый нами класс абстрактным и объявить этот метод абстрактным.\n\nИз примеров абстрактных классов можно еще привести, например, Форма (форму реализует например куб и треугольник), средство передвижения (реализует машина или велосипед)\n\nВоспринимайте абстрактный класс как недопиленный класс, который наследники должны допилить по своему посредством реализации абстрактных методов этого абстрактного класса. Недопиленный он потому что в нем всё же присутствуют реализации (пример метода махания крыльями), но в нем и хватает абстрактных методов, которые должны допилить наследники.                             ",
  "JavaAbstractTitle1": "Абстрактный класс",
  "JavaAbstract2": "Поясним на примере:                                                                                     ",
  "JavaAbstract3": "Вывод:",
  "JavaAnnotTitle": "Аннотации",
  "JavaAnnot1": "Что такое аннотация в Java? \n\nПредставьте себе склад с коробками. На каждой из коробок есть надпись, которая говорит тому кто будет отгружать эти коробки из склада куда эту коробку отгружать. \n\nТак вот, по этой аналогии коробка это класс или переменная или метод, а аннотация это эта надпись, а тот кто отгружает коробку и смотрит на надпись это компилятор Java, который смотрит на аннотацию и делает что-либо с классом или методом или переменной.\n\nНапример с помощью аннотации SafeVarargs над классом можно подавить некоторые предупреждения, которые компилятор бы выдал если бы над этим классом не было этой аннотации. То есть компилятор увидел над классом аннотацию SafeVarargs, которая говорит компилятору не выдавай предупреждения о классе и он этого делать не будет. \nИли аннотация Documented скажет компилятору задокументировать класс над которым она стоит.\n\nДалее на примерах разберем некоторые важные аннотации.",
  "JavaAnnotTitle1": "Аннотация Override",
  "JavaAnnot2": "Override (должно быть самая часто встречающаяся аннотация). Этой аннотацией помечается метод для того чтобы всем программистам смотрящим на него было видно, что метод переопределяется (то есть в родительском классе класса в котором находиться этот метод помеченный аннотацией Override есть метод с таким же именем). \n\nПоясним на примере:                                                       ",
  "JavaAnnot3": "Вывод:",
  "JavaAnnot4": "Также еще служит как страховка. То есть представим, что мы например случайно удалили или закомментировали метод в родительском классе, который переопределялся наследником. Если этот переопределяемый в наследнике метод был помечен аннотацией Override, то при запуске компилятор выдаст соответствующую ошибку сообщающую о том, что аннотация Override здесь ни к чему, поскольку в родительском методе нет метода с таким названием. В примере ниже в ParentClass мы не определили метода с именем someMethod (точнее метод закомментирован, как видим), поэтому программа выдаст ошибку. ",
  "JavaAnnot5": "Вывод:",
  "JavaAnnotTitle3": "Аннотация @FunctionslInterface",
  "JavaAnnot6": "FunctionalInterface - если над интерфейсом написать аннотацию @FunctionalInterface, то в такой интерфейс нельзя будет добавить более одного абстрактного метода (интерфейс с одним единственным абстрактным методом называется функциональным интерфейсом). \n\nТо есть если код содержит в себе интерфейс, который помечен аннотацией FunctionalInterface и который при этом содержит несколько абстрактных методов, то такой код не скомпилируется.\n\nЧто такое функциональный интерфейс, зачем он нужен и как им пользоваться разберем немного позже.\n\nПоясним на примере:                                                       ",
  "JavaAnnot7": "Вывод:",
  "JavaAnnot8": "Как видим код не скомпилировался.                                                 ",
  "JavaAnnotTitle4": "Аннотация @Deprecated",
  "JavaAnnot9": "Deprecated - для пометки устаревших методов или классов. \n\nПри вызове метода вызовется предупреждение, что метод устарел и что его лучше не использовать.\n\nПоясним на примере:                                                       ",
  "JavaAnnot10": "Вывод:",
  "JavaAnnot11": "Как видим, код скомпилировался, но при компиляции было вызвано предупреждение.                                                 ",
  "JavaAnnoTitlet5": "Создание собственных (кастомных) аннотаций.",
  "JavaAnnot13": "Можно создавать свои аннотации с помощью аннотации @interface. \n\nПри создании аннотации используются вспомогательные аннотации. Они пишутся над аннотацией @interface.\n\n@Target - этой аннотацией указываем к чему будет применяться создаваемая аннотация - если укажем TYPE, то только к классу, если METHOD, то только к методу, если FIELD, то только к полю, есть и другие значения, но это основные\n\n@Retention - этой аннотацией указываем где будет жить создаваемая аннотация - если укажем RUNTIME, то создаваемая аннотация должна быть доступна джава машине во время выполнения, если CLASS, то аннотация не будет доступна во время выполнения, но будет в скомпилированном джава class файле, если SOURCE, то создаваемая аннотация будет содержаться только в исходном коде. \n\n@Repeatable(...) - создаваемая аннотация может использоваться несколько раз на методе, классе или поле. В скобочках указывается другая кастомная аннотация. Эта другая кастомная аннотация будет хранить в виде массива ВСЕ повторения применения над конкретным методом или классом, или полем той кастомной аннотации над которой мы писали Repeatable.\n\n@Inherited - создаваемая аннотация наследуется классами, которые наследуют класс к которому применена аннотация.\n\n@Documented - информация о создаваемой аннотации появиться в JavaDoc-документации                                                 ",
  "JavaAnnotTitle6": "Создание собственных (кастомных) аннотаций.",
  "JavaAnnot15": "Поясним на примере:                                                       ",
  "JavaAnonClass1": "Анонимный класс",
  "JavaAnonClass2": "Анонимный класс - одноразовая реализация интерфейса без создания полноценного класса.\n\nТо есть нам не нужно создавать много объектов, будет только один с данной реализацией.\n\nПример программы:                                                ",
  "JavaAnonClass3": "Вывод:",
  "JavaAnonClass4": "Одноразовый он очевидно почему. \nПотому что мы не создавали полноценный отдельный класс реализующий интерфейс, как мы делали это раньше. И мы даже не создавали ссылку для работы с созданным объектом, мы сразу вызвали у него .pow(3,6).\n\nТо есть вся эта реализация существовала для одной цели - вызова метода .pow(3,6) в методе println и всё. И больше нигде мы ее использовать не можем да и не должно быть нужно она одноразовая.                                ",
  "JavaServlMethods1": "Методы сервлета",
  "JavaServlMethods2": "Помимо doGet у сервлета есть и другие методы.\n\nРассмотрим вкратце зачем нужны методы init, doPost, service и destroy.                                         ",
  "JavaArrays1": "Массивы в java",
  "JavaArrays2": "Рассмотрим массивы. \n\nВ прошлых у нас была переменная int a=31; хранящая одно число 31.\n\nА что если мы хотим иметь переменную в которой будет храниться 100 разных числовых значений.\nТакая переменная называется массивом.  \n\nОбъявляется массив так:\nint[] a;\n\n[] значат, что это массив и в нем будет храниться много значений (типа int в данном случае).\n\nПока массив а был просто объявлен. Чтобы в него поместить значения нужно выделить место в памяти где будут храниться значения массива и указать конкретное количество значений, которое может храниться в массиве.\n\nКлючевым словом new мы выделяем память под массив, который может вмещать максимум 5 элементов. \na = new int[5];\nПосле этого можно записывать в эту память числа.\n\nОбъявление и выделение памяти можно записать в одну строку как:\nint[] a = new int[5];\n\t\t\nТакже можно при создании массива сразу записать в них значения.\nint[] b = {56, 3, 7, 63, 13};\n\nЗаранее с помощью new память под эти значения выделять не нужно, так как мы сразу записываем в память значения.",
  "JavaArrays3": "Взаимодействие с массивом",
  "JavaArrays4": "Итак рассмотрим как мы можем взаимодействовать с массивом.\n\nНиже в примере программы создается массив b, который содержит 5 числовых значений.\n\nКаждое из пяти значений имеет свой порядковый номер в массиве: \n56 - имеет номер 0, 3 -  имеет номер 1, 7 -  имеет номер 2, 63 - имеет номер 3, 13 - имеет номер 4. Очевидно, что номера элементам массива выдаются по порядку, то есть первому элементу в массиве номер ноль, второму номер 1, третьему элементу номер 2 и т.д.\n\nТакже как видим порядковый номер в массивах начинается с нуля, а не единицы.\n\nПравильно этот порядковый номер в массиве называть индексом.\n\nПоясним на примере.",
  "JavaArrays5": "Вывод:",
  "JavaArrays6": "Обход массива циклом",
  "JavaArrays7": "Выведем все элементы массива b по порядку с помощью for. \n\nЛюбой массив имеет внутри себя переменную length в которой храниться количество элементов массива. Это можно использовать для обхода элементов циклом.\n\nПоясним на примере.",
  "JavaArrays8": "Вывод:",
  "JavaArrays9": "Как видим, можно легко пройтись по элементам массива и совершать с каждым какие-то действия на каждой итерации. Например, выводить на консоль каждый элемент, как в приведенном примере.",
  "JavaArrays10": "Обход массива циклом for-each",
  "JavaArrays11": "Для обхода элементов массива можно использовать особенный вид for цикла. \n\nНазывается он for-each\n\nИспользуя цикл foreach нам не нужно знать размер массива.\n\nВ примере ниже цикл foreach начиная с первого элемента массива b поочереди берет элементы и помещает их в singleArrayElement\n\nПоясним на примере.",
  "JavaArrays12": "Вывод:",
  "JavaArrays13": "То есть на первой итерации этого цикла берется первый элемент массива b и помещается в переменную singleArrayElement, которая того же типа, что и массив b и в теле цикла можно работать с первым элементом массива через эту переменную, на второй итерации цикла второй элемент помещается в singleArrayElement вместо первого и происходит работа уже со вторым элементом массива, на третьей помещается третий и т.д. до конца массива.\n\nВажно знать, что singleArrayElement это не копия элемента массива, это именно элемент массива, то есть изменяя singleArrayElement мы изменяем элемент массива",
  "JavaArrays14": "Двумерные массивы",
  "JavaArrays15": "Также массивы бывают многомерными. \n\nТо есть представьте массив в котором каждый элемент это массив чисел. \nТакой массив чисел, который мы разбирали только что. \n\nТо есть это массив массивов чисел. Массив массивов называется двухмерным массивом.\n\nНиже пример двухмерного массива. Объявляется он с помощью [][]. Как видим, через запятую перечислены массивы чисел\n\t\tint[][] b = {\n\t\t\t{56, 3, 63, 13},\n\t\t\t{3,67,2},\n\t\t\t{5,5,3,7,9}\n\t\t};\n\t\t\nКак же получить доступ к числам подмассивов. Очень просто. \n\nВ первой скобочке мы пишем индекс нужного нам подмассива.\n\nВо второй скобочке пишем индекс нужного нам числа этого подмассива.\n\nСтрокой кода ниже мы достаем число 2. Мы обращаемся ко второму подмасиву, к третьему элементу этого подмассива.\nSystem.out.println(b[1][2]);\n\nПомним что элементы в массивах нумеруются начиная с нуля. Поэтому 1 и 2, а не 2 и 3.\n\nПоясним на примере.",
  "JavaArrays16": "Вывод:",
  "JavaArrays17": "Обход двумерного массива циклом for-each",
  "JavaArrays18": "Ниже циклами проходимся по числам которые хранит в себе двухмерный массив и выводим их на консоль.\n\nПоясним на примере.",
  "JavaArrays19": "Вывод:",
  "JavaAssert1": "Ключевое слово Assert",
  "JavaAssert2": "Ключевое слово assert для проверки какого-либо условия в ходе разработки.\n\nПрограмма выдает исключение, то есть происходит ошибка если выражение в условии после ключевого слова assert возвращает false.\n\nВ итоговом коде не присутствует, так как используется для простого тестирования условий. \n\nЗапускается с ключом -ea.\n\nПоясним на примере:                                                       ",
  "JavaAssert3": "Вывод:",
  "JavaAssert4": "Как видим, когда выполнение программы доходит до того, что n становиться равным 0 происходит ошибка.                                         ",
  "JavaBreakContinue1": "Ключевое слово break",
  "JavaBreakContinue2": "Далее рассмотрим ключевые слова break и continue.\n\nЕсли нужно раньше времени остановить цикл по какому-то условию, то используется ключевое слово break.\n\nПоясним на примере.",
  "JavaBreakContinue3": "Вывод:",
  "JavaBreakContinue4": "Как видим, цикл for остановился досрочно, то есть і не дошло до 10, цикл остановился когда переменная а стала равна 25.",
  "JavaBreakContinue5": "Ключевое слово continue",
  "JavaBreakContinue6": "Также есть ключевое слово continue.",
  "JavaBreakContinue7": "Оно завершает одну текущую итерацию цикла досрочно.      ",
  "JavaBreakContinue8": "Пример программы:",
  "JavaBreakContinue9": "Вывод:",
  "JavaBreakContinue10": "Как можно увидеть в выводе, на седьмой итерации переменная а уже равна 25, а это значит, что на всех оставшихся итерациях (то есть пока і не станет равна 10) будет срабатывать continue, так как на всех этих оставшихся итерациях переменная a равна 25, что также видно в выводе.",
  "JavaBuffStr1": "BufferedInputStream, BufferedOutputStream - чтение байтового потока и запись в байтовый поток с добавлением буфера для улучшения производительности. \n\nКласс обертка для InputStream с буферизацией. \n\nБлагодаря буферизации потоки, которые переданы в конструктор BufferedInputStream будут читать данные из буфера маленькими порциями, а буфер, чтобы сэкономить время и силы, читает их из потока источника большими порциями.\n\nПример программы:                                ",
  "JavaBuffStr2": "Вывод                                                                                           ",
  "JavaCallable1": "Реализация Callable",
  "JavaCallable2": "Последний вариант того как можно создать класс потока это реализовать Callable.\n\nCallable - как Runnable, только вместо run() - call(), который может возвращать значение, то есть благодаря call поток может вернуть значение.\n\nFutureTask - для взаимодействия с потоками. Он для получения результата выполнения потока (того, что вернет call), еще имеет методы проверки состояния потока.\n\nС помощью метода get() класса FutureTask можно получить результат выполнения потока когда он завершит свое выполнение. \nget() блокирует поток в котором он был вызван пока не выполниться поток переданный в объект FutureTask.\n\nИз также важных методов - с помощью isDone() можем проверить завершился ли уже поток или еще нет.\n\nПример программы:                                                  ",
  "JavaCallable3": "Вывод:",
  "JavaCallable4": "Как видим, get остановил мейн пока выполнялся поток t и когда t выполнился мейн снова запустился и вывел Counter: 5",
  "JavaClone1": "Второй метод Object это метод clone, который клонирует объект. \n\nПроисходит копирование всех полей клонируемого объекта в новый объект-клон. \n\nНо по умолчанию методом clone в новый объект копируются только примитивные поля объекта, а ссылочные нет, поэтому clone тоже нужно переопределять.\n\nВ Java управление объектами осуществляется с помощью ссылочных переменных, и нет оператора для фактического копирования объекта, поэтому и существует clone.",
  "JavaClone2": "Переопределение Clone",
  "JavaClone3": "Напрямую вызвать clone у какого либо объекта в main нельзя, так как метод clone внутри Object объявлен protected.\n\nПоэтому для того чтобы вызвать clone у какого либо объекта его всегда нужно переопределять.\n\nТо есть имеется ввиду, что даже чтобы использовать стандартную реализацию clone, которая копирует только примитивные поля всё равно нужно сделать минимальное переопределение clone, как это сделано в классе SomeClass ниже.\n\nСоздадим два класса в которых будем переопределять clone.\n\nВсе классы, которые переопределяют clone должны реализовывать интерфейс Cloneable. То есть видим ниже в примере программы implements Cloneable\n\nПример программы:                                                  ",
  "JavaClone4": "Вывод:",
  "JavaComments1": "Однострочный комментарий",
  "JavaComments2": "Рассмотрим комментарии. \n\nКомментарии никак не влияют на ход выполнения программы, они лишь нужны чтобы, как можно догадаться, комментировать код.\n\nОднострочный комментарий пишется используя двойной слеш - //.\nКак можно догадаться из названия, это комментарий в одну строчку кода. В примере ниже у нас два однострочных комментария.",
  "JavaComments3": "Их в программе может быть сколько угодно и запуск вышеприведенной программы ничем не будет отличаться от запуска такой же без комментариев.",
  "JavaComments4": "Многострочный комментарий",
  "JavaComments5": "Также комментарии можно писать вот так:\n/* Какой-то комментарий */. \n\nЭто многострочный комментарий. \n\n/* - открывает комментарий\n*/ - закрывает комментарий\n\nОдин однострочный комментарий занимает только одну строку. Один же многострочный комментарий может занимать много строк. Комментарий внутри /* */ можно распределить на много строк. Внизу пример одного многострочного комментария.\nНапример:",
  "JavaComments6": "На комментарии по ходу курса обращайте внимание в них зачастую будет всё основное пояснение программы.",
  "JavaConstr1": "Конструктор",
  "JavaConstr2": "У класса может быть специальный метод без возвращаемого значения и который имеет то же самое имя, что и класс. \n\nЭтот метод называется конструктором.\n\nОн нужен чтобы при создании объекта класса можно было выполнить какие-то действия, например сразу при создании объекта присвоить его полям значения.           ",
  "JavaConstr3": "Вывод:",
  "JavaCountDownLatch1": "CountDownLatch - если нам нужно чтобы какой-то поток ждал пока не выполняться какое-то количество потоков.\n\nВ примере ниже мейн останавливает свою работу с помощью await и когда в потоках вызовется countDown три раза, мейн продолжает свою работу.\n\nПример программы:                                                  ",
  "JavaCountDownLatch2": "Вывод:",
  "JavaCountDownLatch3": "Из консоли видно, что три потока завершили свое выполнение и сразу после этого ожил мейн.",
  "JavaCycles1": "Цикл while",
  "JavaCycles2": "Рассмотрим циклы.\n\nЦикл нужен чтобы повторять какое-о действие или набор действий какое-то количество раз.\n\nЕсть три вида циклов for, while и do..while.\n\nНачнем с while.\n\nПоясним на примере.",
  "JavaCycles3": "Вывод:",
  "JavaCycles4": "Каждую итерацию цикла от A отнимается 1 и когда A становиться 15 (что значит, что A уже будет равна b, а это в свою очередь значит, что выражение a!=b\tуже будет ложью) цикл остановиться.",
  "JavaCycles5": "Цикл for",
  "JavaCycles6": "Также есть цикл for.",
  "JavaCycles7": "Как видим, в программе ниже в скобочках у цикла три выражения разделены точкой с запятой.\n\nПоясним каждое из этих выражений. \n\nПервое выполняется единожды перед первой итерацией цикла for. В нашем случае первое, что происходит когда цикл for запускается, это создание целочисленной переменной i.\n\nВторое выражение, как у нас было в while, при невыполнении которого цикл завершиться.\n\nТретье выражение выполняется в конце каждой итерации цикла.",
  "JavaCycles8": "Пример программы:",
  "JavaCycles9": "Вывод:",
  "JavaCycles10": "То есть переменная i будет каждую итерацию цикла увеличиваться на 1 и пока она не станет равна 10 цикл будет продолжать работать.\nТо есть будет совершено 10 итераций цикла for. \nИ на последней итерации цикла а будет равно 21.\nСтоит упомянуть, что созданная нами переменная і при выходе из последнего цикла удаляется, она живет только в цикле.\n\nЭто самый часто используемый цикл, так как на место этих трех выражений можно ставить что угодно, что очень гибко и удобно.",
  "JavaCycles11": "Цикл do...while",
  "JavaCycles12": "Также есть цикл do...while\n\nРазницы с просто while почти никакой нету, только, как можно увидеть ниже в программе, условие проверяется в конце, а это значит, что одна итерация цикла так или иначе выполниться.",
  "JavaCycles13": "Пример программы:",
  "JavaCycles14": "Вывод:",
  "JavaCycles15": "То есть в отличии от просто while в цикле do...while сначала выполняется код в {} потом проверка условия.     \n\nИногда этот цикл бывает полезен. Но он самый не популярный и его вы будете встречать очень редко.",
  "JavaCyclicBarrier1": "CyclicBarrier - потоки зависают друг за другом в месте вызова await, когда зависло необходимое количество потоков зависнувшие потоки развисают и запускается какой-то другой один поток в котором можно что-то сделать, например использовать то что выполнялось в зависавших потоках.\n\nВ примере ниже мы создаем переменную volatile и потоки добавляют к ней 1, потом в месте await останавливаются и когда зависнет указанное в CyclicBarrier количество потоков потоки развисают и сразу после этого запускается метод run в классе Run. И в этом методе run класса Run будет использована эта ранее изменяемая зависающими потоками переменная.\n\nПример программы:                                                  ",
  "JavaCyclicBarrier2": "Вывод:",
  "JavaCyclicBarrier3": "Как видим шесть потоков остановили свою работу, потом запустился поток Run и вывел 6 и потом потоки продолжили работу.",
  "JavaDBManyTo1": "Базы данных. Связь Многие-ко-Многим",
  "JavaDBManyTo2": "Далее рассмотрим тип связи Многие ко Многим. \n\nНапример. У каждого продукта есть много покупателей и у каждого покупателя есть много купленных продуктов.\n\nЯсное дело должно быть две таблицы - Продукты и Покупатели продуктов. И как-то нужно их связать. \n\nНо для начала следует увидеть одну таблицу в которой хранятся данные обеих только что упомянутых таблиц вместе.",
  "JavaDBManyTo3": "Очевидно, что аттрибуты Имя покупателя, Имейл покупателя и Количество купленных товаров принадлежат не таблице продукты и их нужно отделить в отдельную таблицу Покупатели продуктов.\n\nТакже, как можно увидеть, повторяются в этой таблице и продукты и покупатели. \nНапример, Ricardo купил стол, лампу и утюг, но стол также купили Billy и Van. То есть повторение идет и покупателей и продуктов. \n\nПоэтому таблицы нужно разделить и связать их связью многие ко многим. \nПочему она многие ко многим думаю уже понятно - каждый покупатель может купить МНОГО разных продуктов и каждый продукт может быть куплен МНОГИМИ разными покупателями.",
  "JavaDBManyTo4": "Базы данных. Связь Многие-ко-Многим",
  "JavaDBManyTo5": "Итак разобьем же таблицу на две.                                ",
  "JavaDBManyTo6": "Базы данных. Связь Многие-ко-Многим",
  "JavaDBManyTo7": "Как же нам теперь связать эти две таблицы? \n\nИтак подумаем. Что если, как мы уже делали ранее в таблице продукты, добавить аттрибут Внешний идентификатор покупателя в котором для каждого продукта будут храниться нужные идентификаторы покупателя из таблицы с покупателями.",
  "JavaDBManyTo8": "Но подождите! Если мы посмотрим на исходную таблицу (ту которая на самом первом слайде урока), то стол же купил не только Billy, его купил и Van и Ricardo. Утюг также купил Billy и Ricardo. \nПолучается, что в таблице Продукты на рисунке выше нам нужно размножить стол и утюг. Так, ясное дело, нельзя, ведь нам же нужно минимизировать количество повторений данных в базе.",
  "JavaDBManyTo9": "Базы данных. Связь Многие-ко-Многим",
  "JavaDBManyTo10": "Давайте попробуем наоборот.                                                                         ",
  "JavaDBManyTo11": "Очевидно та же самая ситуация. Только размноживать теперь придется покупателей.                                                               \nКак же быть?",
  "JavaDBManyTo12": "Базы данных. Связь Многие-ко-Многим",
  "JavaDBManyTo13": "Нужно создать третью таблицу. В этой таблице будут всего два аттрибута - Внешний идентификатор продукта и Внешний идентификатор покупателя. То есть очевидно, что в этих аттрибутах будут храниться ключи из других таблиц. И эти ключи разных таблиц будут сопоставлены друг другу, таким образом образуя связь меду двумя таблицами. \n\nПродемонстрируем это:",
  "JavaDBManyTo14": "Как видим, в первом столбике ключи из таблицы продукты, во втором же ключи из таблицы покупатели. \n\nВидим три единицы подряд в первом столбце.\nПолучается мы сопоставляем строку таблицы с продуктами где идентификатор 1 к строке покупателя с идентификатором 1, к строке покупателя с идентификатором 2 и к строке покупателя с идентификатором 3. То есть стол связан с Billy, Van и Ricardo. \n\nВо втором столбце видим три тройки подряд. То есть мы сопоставляем строку таблицы с покупателями где идентификатор 3 к строке продукта с идентификатором 1, к строке продукта с идентификатором 2 и к строке продукта с идентификатором 3. Ricardo связан со столом, лампой и утюгом. \n\nКак видим, множественная связь работает в обе стороны. С одной стороны может быть много столов и с другой стороны может быть много Ricardo.\nИ нам не приходиться, как в исходной таблице (той которая на первом слайде урока), дублировать строки целиком из обеих таблиц. Строки двух таблиц связывает отдельная таблица в которой всего два столбца с числовыми значениями.",
  "JavaDBOneToMany1": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany2": "У каждого продукта может быть категория к которой он принадлежит. \n\nНапример, стол и стул относятся к категории мебель, а лампа, утюг и вентилятор к категории электроприборы.\n\nДавайте же добавим в таблицу из прошлого урока аттрибут Категория продукта. ",
  "JavaDBOneToMany3": "Как видим, слово Электроприбор повторяется три раза, слово мебель два раза. \n\nА что если у нас в таблице будет больше электроприборов и больше мебели, то значит у нас в таблице будут повторяться эти два слова еще больше раз? \n\nИменно поэтому добавлять такой аттрибут, значения которого повторяются много раз, нельзя, так как мы с вами сейчас изучаем реляционную модель базы данных, которая определяет некоторые правила создания БД чтобы в ней практически вообще не было повторяющейся информации.",
  "JavaDBOneToMany4": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany5": "Так как же нам поступить с новым добавленным аттрибутом чтобы не было повторяющейся информации? \n\nВсё просто, нужно его вынести в отдельную таблицу и в ней уже будут храниться уникальные значения, а потом получившиеся две таблицы связать между собой. \n\nТо есть мы сейчас подошли к двум новым концепциям - идентификаторам (чаще называют ключами) и связям.\n\nРазбиваем таблицу. Вторая таблица будет иметь имя Категория продукта.",
  "JavaDBOneToMany6": "Как видим теперь информация не повторяется.",
  "JavaDBOneToMany7": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany8": "Теперь как же связать эти две таблицы? \n\nДля этого используется идентификатор(ключ). \n\nЧто же такое идентификатор?\nНапример, в таблице Продукт можно увидеть аттрибут Идентификатор продукта.\nИдентификатор в этой таблице идентифицирует продукт, по нему можно отличить один продукт от другого.\nСоответственно идентификаторы у продуктов в таблице обязательно должны быть разными чтобы по идентификатору можно было обратиться к одному конкретному продукту.\n\nИдентификаторы продуктов хранятся в отдельном столбце таблицы и ясное дело, как уже было сказано, в этом столбце не должно быть одинаковых значений.\n\nИдентификатор чаще всего это простое числовое значение. \n\nТаблице с категориями тоже добавим аттрибут Идентификатор категории, который будет хранить значения, которые однозначно идентифицируют ту или иную категорию.",
  "JavaDBOneToMany9": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany10": "Итак, теперь давайте уже непосредственно к тому как же связать таблицы. \n\nДля этого в таблице продукт нужно создать дополнительный столбец с внешним ключом, то есть ключ, который внешний, то есть из другой таблицы. Добавим этот столбец.",
  "JavaDBOneToMany11": "На картинке можно увидеть, что значения в столбце 'Внешний идентификатор категории' это значения из столбца 'Идентификатор категории' внешней таблицы категорий. То есть мы связали две таблицы по ключу в таблице с категориями. \n\nИ теперь нету дублирования Мебель или Электроприборы, дублируются только значения идентификаторов этих категорий. ",
  "JavaDBOneToMany12": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany13": "Кто-то может спросить, а какая разница дублируются категории или идентификаторы?\nРазница в том, что в таблице с категориями может быть не один аттрибут, а больше. \n\nНапример:",
  "JavaDBOneToMany14": "Если бы мы не разделяли таблицы, то дублировалось бы уже два аттрибута: ",
  "JavaDBOneToMany15": "Теперь профит от разделения таблиц должен быть очевиден.                   ",
  "JavaDBOneToMany16": "Базы данных. Связь 1-ко-Многим",
  "JavaDBOneToMany17": "Рассмотренный тип связи называется 'Один ко многим'. \n\nВсего типов связей три и мы всех их разберем. \n\nОдин ко многим эта связь, потому что каждому продукту может соответствовать только ОДНА категория, но каждой категории может соответствовать МНОГО продуктов.\nТо есть у нас категории мебель (она одна) соответствует два продукта (их много), а категории электроприборы (она одна) соответствует три продукта (их много). ",
  "JavaDBOneToOne1": "Базы данных. Связь 1-к-1",
  "JavaDBOneToOne2": "Последний вид связи - это Один к одному. \n\nЭтот вид связи Самый простой. \nКак понятно из названия, каждой строке одной таблицы соответствует только одна строка в другой. \n\nПочти не используется за редкими исключениями, так как очевидно, что соединение таблиц связанных таким образом в одну не приведет к дублированию данных. \n\nНо бывают случаи когда это бывает полезно. ",
  "JavaDBOneToOne3": "Базы данных. Связь 1-к-1",
  "JavaDBOneToOne4": "Самый полезный случай - это когда мы хотим отделить из основной таблицы данные, которые относятся только к ее части. \n\nНапример, есть наша основная таблица Продукты.\nИ пусть в ней будет новый аттрибут - Бракованный товар. То есть например, все лампы из тех, что есть на складе оказались бракованными или все стулья, которые есть на складе оказались бракованными. То есть представим, что эти все стулья и лампы это какая-то конкретная их модель и эта модель выпускалась с браком, такое бывает. Тогда у них в этом столбце будет стоять true, то есть бракованные, если всё в порядке то false.",
  "JavaDBOneToOne5": "Так вот, очевидно, что у большей части продуктов в таблице будет стоять false. Так как такой массовый брак какого-то продукта это скорее редкость.",
  "JavaDBOneToOne6": "Базы данных. Связь 1-к-1",
  "JavaDBOneToOne7": "Для того чтобы нам не хранить информацию в таблице с продуктами о том, что с ними всё в порядке можно вынести информацию о том, что какие-то продукты бракованные в отдельную таблицу. ",
  "JavaDBOneToOne8": "И ясное дело в этой новой таблице, как видим, намного меньше записей, чем если бы информация о браке хранилась в формате столбца в таблице с продуктами, так как уже было сказано в ней нет информации о том, что какие-то продукты не бракованные. То есть, как видим, в ней нету false, эту информацию в этой таблице хранить незачем, поскольку если у какого-то продукта нету связанной строки в таблице барка, это само по себе значит, что продукт не бракованный. То есть у стола, утюга и вентилятора нету связи с таблицей брака и это само по себе значит, что с этими продуктами всё в порядке.",
  "JavaDBOneToOne9": "Базы данных. Связь 1-к-1",
  "JavaDBOneToOne10": "Второй случай использования связи Один к одному - зто если, например, в таблице слишком много столбцов, то чтобы ее немного уменьшить можно некоторые столбцы вынести в отдельные таблицы.\n\nТретий случай - это когда у нас, например, есть таблица с продуктами и у продуктов появляется какой-то новый ВРЕМЕННЫЙ аттрибут. То есть мы точно знаем, что этот столбец мы со временем удалим из таблицы. И создавать новый столбец в основной таблице не всегда бывает удобно, легче создать отдельную таблицу чтобы потом с легкостью ее удалить.\n\nЧетвертый случай - это из соображений безопасности. То есть если злоумышленник получит доступ к основной таблице, а в ней есть какие-то очень секретные аттрибуты, то он может просто пройтись по строкам таблицы и выбрать эти все секретные данные. очевидно безопаснее было бы хранить эти секретные данные в виде отдельных таблиц чтобы хацкер не смог получить их всех скопом.\n\nВСё!! С этой информацией вы сможете спроектировать реляционную БД любой сложности.",
  "JavaDBBasics1": "Базы данных. Азы",
  "JavaDBBasics2": "Что такое база данных? \n\nДумаю можно догадаться, что это хранилище в котором хранятся данные.\n\nНаиболее удобный вариант хранения данных в БД в виде таблиц. \nКонкретная таблица БД хранит в себе данные какой-либо конкретной сущности.\n\nНапример, есть таблица сущности 'Продукт'. В этой таблице могут храниться много разных продуктов (там стол, стул, лампа и т.д.).\n\nКаждая строка таблицы хранит характеристики конкретного продукта, то есть одного из этих многих продуктов. \nТо есть, например, одна строка таблицы хранит данные о лампе, другая о стуле и т.д. \n\nСтроки таблицы разбиты на ячейки. \nВ каждой ячейке строки храниться конкретная какая-либо характеристика конкретного продукта (например стула). ",
  "JavaDBBasics3": "Базы данных. Азы",
  "JavaDBBasics4": "Как и в вообще почти любой на свете таблице, ячейки строки таблицы формируются по столбцам и у этих столбцов таблицы зачастую есть имена. Есть имена и у столбцов таблиц в БД.\n\nНапример имя продукта, цена продукта, количество на складе или другое. То есть названия характеристик продукта по которым определяется в какую ячейку строки конкретного продукта значение какой характеристики помещать.\n\nСтолбцы таблицы принято называть аттрибутами, а строки кортежами.\n\nСейчас на примере таблицы Продукт будет понятнее.",
  "JavaDBBasics5": "Видим аттрибуты продуктов таблицы (Идентификатор продукта, Наименование продукта, Цена продукта, Количество на складе).\nТакже видим пять кортежей (значит пять продуктов). \n\nЕсли мы представим, что это таблица базы данных используется в реальном магазине, то ясное дело если какой-нибудь из товаров купят, то его количество в таблице должно уменьшиться, если цена на него уменьшиться, то тоже таблица должна быть отредактирована. Редактирование таблицы совершается специальными командами о которых поговорим позже.",
  "JavaDataStream1": "DataInputStream DataOutputStream - чтение байтового потока и запись в байтовый поток в формате примитивных типов данных.\n\nПример программы:                                ",
  "JavaDataStream2": "После dos.writeDouble(56.45); в файл double.txt записывается число 56.45 (в формате double, поэтому оно так выглядит в файле).",
  "JavaDataStream3": "С помощью double inpStrDouble = dis.readDouble(); считываем из файла число, которое в формате double в переменную double.",
  "JavaDefault1": "Default методы в интерфейсах",
  "JavaDefault2": "В java 8 всё же появилась возможность добавлять реализации методов в интерфейс. \n\nНужно в основном для того чтобы не было у классов реализующих интерфейс слишком много одинаковых реализаций абстрактных методов интерфейса.\n\nДо java 8 приходилось делать так:                                                ",
  "JavaDefault3": "Вывод:",
  "JavaDefault4": "Default методы в интерфейсах",
  "JavaDefault5": "Добавив дефолтные реализации gas и brake в интерфейс всем классам, которые реализуют Car больше не придется делать одинаковые реализации этих методов.\n\nПосле java 8:                                                ",
  "JavaDefault6": "Вывод:",
  "JavaDockerEx1": "Приложение, которое будет собираться в Docker Image",
  "JavaDockerEx2": "В этом уроке соберем простейшее Spring Boot приложение в Docker image, запустим его и загрузим на Docker Hub. \nЕго структура приведена ниже. В ней ничего особенного за исключением того, что в корне проекта добавлен файл с именем Dockerfile.",
  "JavaDockerEx3": "В контроллере один простой обработчик, который возвращает строку Hello World!!!.",
  "JavaDockerEx4": "Настройка сборки",
  "JavaDockerEx5": "Настраивается сборка Docker Image с помощью файла с названием Dockerfile, который необходимо создать в корне проекта, как можно было увидеть на предыдущем слайде.\n\nИтак. Было упомянуто, что всё, что нужно для запуска приложения докером должно уже быть в его Docker Image, чтобы не пришлось развертывать приложение и устанавливать кучу всего по отдельности. \nТак вот откуда же берется внутри image, который получается в результате сборки всё ПО, что будет запускать наше приложение (jdk например), все ПО, что будет скачивать зависимости для него (maven например) и т.д.? \nВсё просто, оно есть в интернете и когда производиться команда сборки приложения происходит скачивание его из интернета и помещение скачанного ПО в результирующий Docker Image. \nТакже при сборке приложения докер производит его настройку (например, закачку зависимостей) используя скачанное для этого ПО (например, докер скачал мавен и сразу производит им закачку зависимостей в собираемый Docker Image). При запуске же собранного Docker Image докер берет сказанное ПО для запуска и запускает им приложение(например, берет из скачанного jdk утилиту java и запускает ей spring-boot приложение).\nТак вот, то какое ПО будет скачиваться в результирующий Docker Image, то как им будет настраиваться или запускаться приложение внутри Docker Image как раз настраивается в Dockerfile.",
  "JavaDockerEx6": "ПО для сборки с сайта Docker Hub.",
  "JavaDockerEx7": "Итак, из программ из интернета, которые нам нужны для сборки и запуска, нужно будет указать в Dockerfile мавен для загрузки зависимостей и сборки приложения в jar и jdk для запуска собранного мавеном jar файла приложения.\nИх можно найти на сайте Docker Hub. Там можно найти мавен репозиторий ",
  "JavaDockerEx8": "и в тегах выбрать подходящую версию для нашего приложения.",
  "JavaDockerEx9": "Таким же образом можем найти репозиторий jdk.",
  "JavaDockerEx10": "И в его тегах тоже можно поискать подходящую версию jdk.",
  "JavaDockerEx11": "Очевидно, что ПО скачиваемое в Docker Image нашего спринг приложения тоже является Docker Image.",
  "JavaDockerEx12": "Перейдем же к самому Dockerfile. \nСборка Docker Image происходит посредством последовательного выполнения команд прописанных в Dockerfile. Рассмотрим содержимое Dockerfile спринг приложения, которое мы будем собирать в Docker Image.",
  "JavaDockerEx13": "Сборка приложения в Docker Image",
  "JavaDockerEx14": "Давайте в консоли перейдем в корневую папку спринг проекта, который мы собираемся собирать в Docker Image и собственно соберем его в Docker Image с помощью комманды: \n\ndocker build -t michaelshadrin/simple-spring-boot-app:version1 .\n\nЗдесь michaelshadrin/simple-spring-boot-app это название репозитория, который будет создан на сайте Docker Hub если мы захотим загрузить туда получившийся в результате этой команды Docker Image. Важно уточнить, что перед слешем в названии репозитория всегда указывается username аккаунта Docker Hub.\nversion1 это имя версии приложения собираемого в Docker Image и если загрузить получившийся Docker Image на Docker Hub, то в разделе Tags в репозитории michaelshadrin/simple-spring-boot-app можно будет увидеть Docker Image с названием version1.",
  "JavaDockerEx15": "Процесс сборки может быть довольно долгим, так как в процессе сборки скачиваются jdk, maven, зависимости и другое.",
  "JavaDockerEx16": "Запуск Docker Image.",
  "JavaDockerEx17": "Давайте запустим получившийся Docker Image. Важно отметить, что перед этим необходимо включить на компьютере приложение Docker Desktop ссылка для скачивания которого давалась ранее.\nЗапускается получившийся Docker Image той самой, уже не раз упомянутой командой, которой запускается вообще любой Docker Image - командой docker container run. \nВыполним ее для запуска нашего Docker Image:",
  "JavaDockerEx18": "В команде указывается пара портов -p 8081:8080. Первый порт - это порт компьютера на котором мы запускаем Docker Image, второй - это тот, что мы указывали в Dockerfile, то есть тот на котором запускается Docker Image в Docker Hub. \nПосле указания портов очевидно указывается название репозитория и имя конкретного Docker Image в нем, то есть имя версии.\n-d пишется в команде просто чтобы запущенный Docker Image не был привязан к консоли в которой он запускается. То есть, чтобы мы могли дальше использовать эту консоль после запуска Docker Image.\n\nИтак, Docker Image запущен, а значит и Spring boot приложение в нем тоже. Давайте обратимся к обработчику helloWorld этого приложения через порт компьютера 8081, который мы указывали в команде запуска Docker Image.",
  "JavaDockerEx19": "Как видим, обработчик успешно вернул Hello World!!!, что значит, что сборка приложения в Docker Image и запуск этого Docker Image прошли успешно.",
  "JavaDockerEx20": "Запуск Image. Контейнеры",
  "JavaDockerEx21": "Работающий, запущенный Docker Image называется контейнером. Запущенных, одновременно работающих докер контейнеров может быть много. Чтобы несколько Docker Image работали одновременно их нужно запустить на разных портах компьютера.\nДавайте запустим три контейнера одного и того же Docker Image на порте 8081, на порте 8082 и на порте 8083.",
  "JavaDockerEx22": "И ко всем можно будет иметь доступ через localhost по соответствующему порту.",
  "JavaDockerEx23": "Запуск Image. Контейнеры",
  "JavaDockerEx24": "С помощью команды docker container list можно просмотреть все работающие контейнеры. ",
  "JavaDockerEx25": "В результате этой команды можно увидеть разную информацию о контейнере, в том числе id запущенного контейнера. С помощью команды docker container stop можно остановить контейнер по этому id. Не обязательно писать id контейнера полностью, можно написать лишь его первые несколько символов.",
  "JavaDockerEx26": "Как видим, теперь работают только два контейнера, один мы остановили.",
  "JavaDockerEx27": "Загрузка Image на Docker Hub",
  "JavaDockerEx28": "Можно загрузить Docker Image, который мы собрали в Docker Hub. Сделать это можно через консоль посредством команды или через графический интерфейс приложения Docker Desktop. Сделаем это через Docker Desktop.\nВ приложении в разделе Images можно увидеть Image, который мы собирали. Чтобы загрузить его на Docker Hub достаточно лишь нажать на три точки и выбрать push. Начнется загрузка.",
  "JavaDockerEx29": "После загрузки в аккаунте с именем michaelshadrin (то что указывается до слеша в названии репозитория) должен появиться репозиторий michaelshadrin/simple-spring-boot-app, который будет содержать Image, который загружался.",
  "JavaDockerEx30": "В Tags этого репозитория видим image с названием version1.",
  "JavaDockerEx31": "О пользе Docker",
  "JavaDockerEx32": "Еще раз о преимуществах докера. \n\nПредставим себе ситуацию когда, например, вебсайт создают два человека - фронтенд часть один человек, а бэкенд часть другой. Фронтендер написал свою фронтенд часть и хочет протестировать ее как часть полноценного вебсайта. Для этого ему нужна вторая часть вебсайта - бэкенд. Тогда фронтендер может попросить у бэкендера image бэкенда, чтобы запускать этот image у себя на компьютере командой docker container run для тестирования взаимодействия разработанного фронта с беком. При этом фронтендер не занимаеться муторным развертыванием этого бэкенда у себя на компьютере, он может даже не знать на каком языке бэкендер его написал. Как видим, докер очень удобен при разработке приложений в команде. \nВообще всё может быть намного круче, приложение может состоять не из двух частей, а из множества микросервисов и каждый из них можно упаковать в отдельный image и всех их запускать одинаковой командой docker container run.\n",
  "JavaDockerHub1": "Подготовительные действия",
  "JavaDockerHub2": "Для начала работы с Docker необходимо его скачать и установить на компьютер по ссылке: https://www.docker.com/products/docker-desktop/\n\nТакже необходимо создать аккаунт на сайте Docker Hub по ссылке: https://hub.docker.com/signup.\n\nТам всё довольно стандартно и интуитивно, поэтому не будем заострять внимание.",
  "JavaDockerHub3": "Что такое Docker Hub, Repository, Tag?",
  "JavaDockerHub4": "Итак, как мы поняли, Docker image - это итоговый файл, который получается в результате сборки приложения с помощью Docker. \nЭтот файл содержит в себе приложение и все необходимые технологии для его запуска.\n\nКогда разработчик собрал докером приложение, он может загрузить получившийся Docker image в интернет на сайт Docker Hub. \nДопустим два приложения было собрано в Docker Image и загружено на Docker Hub. Тогда их можно увидеть на этом сайте:",
  "JavaDockerHub5": "Теперь если какой-либо человек захочет запустить один из этих Docker image со своего докер аккаунта на своем компьютере командой docker container run -d -p 8081:8080 michaelshadrin/ecommerce-backend-app-docker:version1, то даже если на его компьютере нет запускаемого этой командой Docker Image произойдет скачивание этого Docker Image из интернета ",
  "JavaDockerHub6": "и после этого запуск этого Docker Image. Можно увидеть, что происходит Pulling from michaelshadrin/ecommerce-backend-app-docker, то есть скачивание ecommerce-backend-app-docker. Согласитесь довольно удобный механизм.",
  "JavaDockerHub7": "Репозитории, теги на сайте Docker Hub",
  "JavaDockerHub8": "На прошлом слайде на картинке можно было увидеть два загруженных на сайт приложения собранных в Docker Image. Так вот, те два приложения на картинке, которые находятся на сайте правильно называть не приложениями, а репозиториями этих двух приложений. Называются они так, потому что каждый репозиторий хранит в себе не один Docker Image приложения, а много Docker Image разных версий одного и того же приложения. То есть если мы нажмем на один из репозиториев на сайте:",
  "JavaDockerHub9": "то в разделе теги можно увидеть много Docker Image, которые являются разными версиями одного и того же приложения. То есть, ясное дело, разработчик по ходу разработки приложения будет собирать его в Docker Image не один раз, приложение будет изменяться и собирать новую его версию в Docker Image и загружать ее на сайт нужно будет не раз и все версии одного и того же приложения будут храниться в конкретном Docker Repositiry.\nЕще раз, конкретное приложение связано с конкретным Docker Repository для него. У нас было два репозитория для двух разных приложений.",
  "JavaDockerInfo1": "Docker. Что это?",
  "JavaDockerInfo2": "С помощью докер можно запускать любые приложения реализованные любыми технологиями на любых языках программирования одной и той же командой.\nВот такой: \n\ndocker container run -d -p 8081:8080 michaelshadrin/simple-spring-boot-app:version1 .\n\n Ее содержимое разберем позже.\n\nДля того чтобы запустить приложение этой командой его нужно собрать в Docker Image.",
  "JavaDockerInfo3": "Docker. Что это?",
  "JavaDockerInfo4": "Один раз собранное докером приложение в Docker image можно запустить даже на компьютере где не установлены различные необходимые программы, зависимости проекта, языки программирования на которых реализовано приложение.\nТо есть раньше для развертывания приложения на компьютере нужно было установить все необходимые технологии для его работы. \nНапример, для запуска spring boot приложения необходим jdk, maven, зависимости прописанные в pom. То есть нам приходилось отдельно скачивать jdk, потом отдельно скачивать maven вместе со spring boot приложением (поскольку maven встроен в spring boot приложение), потом отдельно скачивать зависимости проекта через этот maven. Это и называется развертывание приложения на компьютере. \nТеперь с докером, как мы уже поняли, всё намного проще. \n\nВнутри Docker Image получившимся в результате сборки приложения УЖЕ ЕСТЬ всё, что нужно для запуска этого приложения и любой человек может запустить приложение очень просто ранее упомянутой командой без муторного его развертывания.",
  "JavaDockerInfo5": "Docker. Что это?",
  "JavaDockerInfo6": "Докер имеет стандартизированный способ сборки проекта. \nТо есть любые приложения использующие какие-угодно технологии имеют подобный способ сборки и в результате сборки имеют одинаковый итоговый формат. \nТакже Docker Image можно запускать одинаковым образом где угодно - на компьютере, в облаке или где-либо еще.",
  "JavaEquals1": "Equals",
  "JavaEquals2": "Следующий метод Object - это equals. \n\n Возвращает boolean значение. \n\n equals по умолчанию проверяет только то, ссылаются ли две ссылки на один и тот же объект. \n\n Если нам нужно проверить не только это, а является ли содержимое одного объекта одинаковым с другим объектом, то его нужно переопределять.",
  "JavaEquals5": "Переопределение Equals",
  "JavaEquals3": "Пример программы:                                                  ",
  "JavaEquals4": "Вывод:",
  "JavaExceptions1": "Обработка исключений",
  "JavaExceptions2": "Если при работе Java приложения возникает ошибка(исключение) и обработка данной ошибки не предусмотрена в программе этого приложения, то приложение ОСТАНОВИТ свою работу и программисту, который запустил это приложение или пользователю, который использовал это приложение демонстрируется в виде большого и страшного StackTrace, что же с приложением случилось и какая ошибка произошла. Такой StackTrace мы все видели когда запускали программу с ошибкой. \n\nС помощью обработки ошибок можно сделать так чтобы приложение не останавливало свою работу даже если произошла ошибка, то есть можно сделать так чтобы пользователю например показалось сообщение \"Невозможно сейчас выполнить данную операцию, потому что при выполнении данной операции произошла такая-то ошибка!\" уже в виде красивого всплывающего окна вместо страшного StackTrace и главное, что приложение при этом продолжит работать. \n\nОбработка ошибок совершается с помощью try и catch. И еще finally можно иногда.",
  "JavaExceptions3": "Обработка исключений с помощью try catch",
  "JavaExceptions4": "Если в коде try возникнет исключение указанное в круглых скобочках рядом с catch, то выполняется код в catch.\n\nПоясним на примере:                                                       ",
  "JavaExceptions5": "Вывод:",
  "JavaExceptions6": "Throw и Throws",
  "JavaExceptions7": "По теме исключений еще нужно знать два ключевых слова throws и throw.\n\nПоясним на примере:                                                       ",
  "JavaExceptions8": "Вывод:",
  "JavaExceptions9": "Как видим при запуске программы происходит возбужденная нами ошибка.                                             ",
  "JavaExecutorService1": "Создание потока дорогостоящая операция.\n\nПоэтому можно вместо создания новых потоков переиспользовать те которые завершили свою работу.\n\nExecutorService помогает поддерживать пул потоков, то есть поддерживает выполнение некоторого фиксированного количества потоков, которые одновременно выполняются. \n\nТакже он назначает задачи этим потокам в этом пуле (в пуле всё время находятся те же самые потоки, это важно). \n\nОн также предоставляет возможность ставить задачи в очередь до тех пор, пока не появится свободный поток в пуле, если количество задач превышает количество доступных потоков.\n\nКак уже было сказано ExecutorService создает некоторый пул потоков. \nЕсли пул потоков имеет размер 10 то параллельно выполняться будет всего 10 потоков и как только один из 10 потоков завершит свою работу, он не создается заново, он перезапускается для выполнения уже другой задачи. \nТо есть потоки в пуле потоков не создаются заново, а переиспользуются.\n\nЭто частно может быть полезно в клиент-серверных программах. \nТо есть представим, что чтобы обработать один запрос клиента сервер создает отдельный поток. Когда серверной программой обрабатываются запросы клиентов, из-за большого количества потоков может увеличиваться время отклика (промежуток времени, который требуется серверу, чтобы обработать запрос извне). То есть требуется дополнительное время для постоянного создания нитей на сервере, что приводит к увеличению времени отклика и чтобы постоянно не создавались потоки на сервере дла обработки запросов, ExecutorService может помочь. То есть запросы будут выполняться в ExecutorService, в котором потоки переиспользуются для обработки запросов клиентов, и если в ExecutorService нет места, запросы становиться в очередь и будут ждать пока освободиться поток в ExecutorService.\n\nТакже это полезно тем, что в процессе может создаться лишь ограниченное количество потоков. Благодаря ExecutorService больше заданного в конструкторе количества потоков не создастся и ясное дело ExecutorService экономит ресурсы и время. Достигается желаемая нагрузка и не подвергаются опасности системные ресурсы.                                         ",
  "JavaExecutorService2": "Пример программы:                                                  ",
  "JavaExecutorService3": "Вывод:",
  "JavaExecutorService4": "То есть ExecutorService нам нужен чтобы некоторое количество потоков, некоторое продолжительное время переиспользовалось для выполнения каких-либо задач."
}